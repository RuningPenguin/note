
# js基础

## js的组成
- ECMAScript: 规定js语法
- DOM: 文档对象模型, 提供了页面的操作: document
- BOM：浏览器对象模型, 提供了浏览器的操作: window


## js写在哪
1. 外部:
  - `script`的src属性引入
    - 自动执行
    - 先写的执行
    - 一般放在head或body的最后

2. 内部:
    - `script`标签包裹
    - 自动执行
    - 先写的执行
    - 一般放在head或body的最后
3. 内联:
    - 作为html属性值存在（行为相关属性）
    - 配合行为使用
    - 不建议使用(结构和行为的分离，优化项目，便于管理，只是为了测试方便)
```js:
<input type="button" onclick="alert('hello world')" value="点我试试">
```

::: tip a标签阻止点击刷新
`<a href="javascript:void(0)">超链接</a>`
:::

## js写什么

#### js的打印语句
- 弹出信息框：`alert()`
    - BOM，阻塞程序执行，有隐式类型转换
- 打印到页面：`document.write()`
    - DOM，影响页面布局，有隐式类型转换
- 打印到控制台：`console.log()`     √
    - BOM（浏览器的V8引擎），不影响页面布局，不阻塞程序执行，没有隐式类型转换

#### js中的数据类型
- 基本数据类型：String、Number、Boolean、Null、Undefined、Symbol、BigInt
- 引用数据类型：Object【Object是个大类，function函数、array数组、date日期...等都归属于Object】
- 数据类型的检测方法：`typeof(要检测的数据或变量)`或`typeof 要检测的数据或变量`
    - typeof自身的执行结果，必然是字符


#### js的变量的创建和使用
- 创建：
  - 关键字：`var`
- 变量名的规则
  - 只能使用字母，下划线，`$`开头
  - 不允许使用，关键字和保留字
    - 关键字：官方已经赋予了功能的单词
    - 保留字：官方暂时没有赋予功能，但是将来可能会赋予功能
      - 技巧：加前缀
          - 数据类型的缩写
          - 功能的缩写
          - 页面的缩写
          - 公司名的缩写
    - 尽量语义化，词必达意
- 驼峰式
  - 大：从第一个单词的首字母大写
      - 构造函数
  - 小：从第二个单词的首字母大写
      - 一般情况
- 变量声明的小技巧
    - 声明时就赋值
    - 批量声明
    - 批量赋值

#### 数据的运算
- 算数运算符
  - `+ - * / %`
- 关系运算符（比较）
  - `> >= < <= != !== == ===`
- 逻辑运算符
  - `|| && !`
- 赋值运算符
  - `= += -= *= /= %=`
- 一元运算符
  - `++ --`

#### <RouterLink to="/doc/basics/js/core.md#进制的转换">进制的介绍</RouterLink>
- 十进制：逢10进1：0123456789
- 二进制：逢2进1：01 10 11 100
- 八进制：逢8进1：01234567 10 11 12
- 十六进制：逢16进1：0123456789abcdef 10

#### 浮点数的精度问题
- 事关的转换数据丢失问题，导致某些小数的计算不精确
  - 如：0.1+0.7!=0.8
- 处理方式，主动保留n位小数，并转回数值

#### 非法的数值运算结果：NaN
- 不是一个数字 的 数值型数据
- NaN不等于任何数据（包括自己）
- NaN的专用的检测方式：`isNaN()`


## 数据的类型转换
::: tip
- 因为直接得到的数据，可能不符合目前的程序要求，需要转成指定数据之后，才能使用
- 如：从页面获取的内容，都是字符
:::

#### 转换方式
**隐式类型转换**
- 隐式：没有主动做，**在执行过程中，转换了，执行结束后，原数据未改变**
  - 场景：什么情况下会发生转换
    - 运算符
      - 算术
      - 关系
      - 逻辑
  - 规则：转换规则是什么
    - 算术
      - `+`：只要有一边是字符，结果就是字符
      - `- * / %`：都是转成数值
    - 关系
      - 只要有一边是数值，转成数值
    - 逻辑
      - 转布尔

**强制类型转换**
- 强制：主动转换，可以拿到转换结果
  - 字符转数值
    - `parseInt(要转换的字符)`
      - 将字符转成整数，从左向右依次检测，能转则转，不能转，则停，第一位不能转，直接NaN，不识别小数点
    - `parseFloat(要转换的字符)`
      - 将字符转成小数，从左向右依次检测，能转则转，不能转，则停，第一位不能转，直接NaN
    - `Math.round(要转换的字符)`
      - 不是专门做数据转换，处理数据的过程中，可以转换
      - 严格转换，不允许任何位置出现非数字的字符
      - 四舍五入取最近的整数
    - `Number(要转换的字符)`
      - 不是专门做数据转换，处理数据的过程中，可以转换
      - 严格转换，不允许任何位置出现非数字的字符
  - 数值转字符
    - `要转换的数值.toString()`
      - 直接转，没有规则
    - `要转换的数值.toFixed(n)`
      - 直接转，根据传入的数字，决定保留n为小数，不够的位数补零
    - `String()`
      - 不是专门做数据转换，处理数据的过程中，可以转换
      - 直接转，没有规则
    - 其他转布尔
      - `Boolean()`
        - 不是专门做数据转换，处理数据的过程中，可以转换
        - 数值：非0为true，0为false
        - 字符：非空为true，空为false
        - undefined，null，NaN，都是false
        - 对象，数组，函数，都是true


::: tip js的三大特殊数据
1. null
2. undefined
3. NaN
:::


## 程序的结构
1. 顺序结构
    - 代码或功能的执行顺序，自上而下，按照固定的流程依次执行
2. 选择（分支）结构
    - 根据不同的条件或时机，选择不同的功能或代码执行
3. 循环结构
    - 重复执行，为了避免死循环，需要在每次执行之前，做条件判断，继续执行或停止
    
### 选择（分支）结构
1. 实现
    - 分支语句
        - 单分支：if
        ```js
        if(条件){
            条件为true，执行代码
        }
        ```
        - 双分支：if-else
        ```js
        if(条件){
            条件为true，执行代码1
        }else{
            条件为false，执行代码2
        }
        ```
        - 多分支：switch
        ```js
        switch(要判断的值或变量){
            case 可能的值1:
                执行代码1
                break;
            case 可能的值2:
                执行代码2
                break;
            ...
            default:
                以上条件都不符合，执行这里的代码
        }
        ```
- 默认情况下，case语句判断成功后，就不再向下判断了，形成了穿透特性
- 阻止穿透：break


| 分支语句 | 使用场景 | 是否有隐式类型转换 |
| :--- | :--- | :--- |
| if | if语句更擅长判断范围 | 是 |
| switch | switch语句更擅长判断具体的值 | 否 |


::: tip 补充
- 三目表达式
  - 条件 ? 值1 : 值2
  - `res = n<10 ? "0"+n : ""+n;`

- 逻辑短路
    - `console.log( 2 || 3 )`
    - `console.log( 0 || undefined )`
    - `console.log( undefined || 0 )`
:::
    

    
### 循环的语句
- while
```js
  // 初始化计数器
  while(执行条件){
      要重复执行的代码
      改变计数器
  }

  var i = 0;
  while(i<10){
    console.log(i);
    i++;
  }
```
- do-while：**无论如何都会至少执行一次**
```js
  初始化计数器
  do{
      要重复执行的代码
      改变计数器
  }while(执行条件)

  var i = 0;
  do{
    console.log(i);
    i++;
  }while(i<10);
```
- for
```js
  for(循环的三要素：初始化计数器;执行条件;计数器的改变){
      要重复执行的代码
  }

  for(var i = 0; i < 10; i++){
    console.log(i);
  }
```

::: tip 循环关键字
- break：结束当前循环，后面没执行完的，都不再执行了
- continue：跳过本次循环，继续执行，后面的次数
:::


#### <RouterLink to="/doc/basics/js/core.md#递归">死循环(递归)</RouterLink>
- 无法通过自身控制结束的循环
- 消耗大量的内存，浪费性能，影响程序执行
- 但是，可以利用死循环的思想，配合循环的控制关键字，解决问题

