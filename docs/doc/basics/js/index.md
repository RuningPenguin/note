# javascript

## js基础

### js的组成

- ECMAScript：语法
- DOM：文档对象模型：提供了页面的操作：document
- BOM：浏览器对象模型：提供了浏览器的操作：window

### js写在哪

- 外部：
    - script的src属性引入
    - 自动执行
    - 先写的执行
    - 一般放在head或body的最后
- 内部：
    - script标签包裹
    - 自动执行
    - 先写的执行
    - 一般放在head或body的最后
- 内联：
    - 作为html属性值存在（行为相关属性）
    - 配合行为使用
    - 不建议使用

### js写什么

#### js的打印语句

- 弹出信息框：`alert()`
    - BOM，阻塞程序执行，有隐士类型转换
- 打印到页面：`document.write()`
    - DOM，影响页面布局，有隐士类型转换
- 打印到控制台：`console.log()`     √
    - BOM（浏览器的V8引擎），不影响页面布局，不阻塞程序执行，没有隐士类型转换

#### js中的数据类型

- 基本类型：字符string，数值number，布尔boolean，undefined，null
- 复杂类型：对象object，函数function
- 数据类型的检测方法：`typeof(要检测的数据或变量)`或`typeof 要检测的数据或变量`
    - typeof自身的执行结果，必然是字符

#### js的变量的创建和使用

- 创建：
    - 关键字：`var`
- 变量名的规则
    - 只能使用字母，下划线，$开头
    - 不允许使用，关键字和保留字
        - 关键字：官方已经赋予了功能的单词
        - 保留字：官方暂时没有赋予功能，但是将来可能会赋予功能
        - 技巧：加前缀
            - 数据类型的缩写
            - 功能的缩写
            - 页面的缩写
            - 公司名的缩写
            - 自己名字的缩写
    - 尽量语义化，词必达意
    - 驼峰式
        - 大：从第一个单词的首字母大写
            - 构造函数
        - 小：从第二个单词的首字母大写
            - 一般情况
- 变量声明的小技巧
    - 声明时就赋值
    - 批量声明
    - 批量赋值

#### 数据的运算

- 算数运算符
    - `+ - * / %`
- 关系运算符（比较）
    - `> >= < <= != !== == ===`
- 逻辑运算符
    - `|| && !`
- 赋值运算符
    - `= += -= *= /= %=`
- 一元运算符
    - `++ --`

#### 进制的介绍

- 十进制：逢10进1：0123456789
- 二进制：逢2进1：01 10 11 100
- 八进制：逢8进1：01234567 10 11 12
- 十六进制：逢16进1：0123456789abcdef 10

#### 浮点数的精度问题

- 事关的转换数据丢失问题，导致某些小数的计算不精确
    - 如：0.1+0.7!=0.8
- 处理方式，主动保留n位小数，并转回数值

#### 非法的数值运算结果：NaN

- 不是一个数字 的 数值型数据
- NaN不等于任何数据（包括自己）
- NaN的专用的检测方式：`isNaN()`

#### js如何操作页面中的元素 - 输入框和按钮

- 页面上有许多元素
- 要操作哪个？选中！js的选择器
- 要操作什么？属性！
- 哪个属性？value属性
- 哪个属性？onclick属性
### 数据的类型转换

#### 为什么要对数据进行类型的转换

- 因为直接得到的数据，可能不符合目前的程序要求，需要转成指定数据之后，才能使用
- 如：从页面获取的内容，都是字符

#### 转换方式

- 隐式：没有主动做，**在执行过程中，转换了，执行结束后，原数据未改变**
    - 场景：什么情况下会发生转换
        - 运算符
            - 算术
            - 关系
            - 逻辑
    - 规则：转换规则是什么
        - 算术
            - `+`：只要有一边是字符，结果就是字符
            - `- * / %`：都是转成数值
        - 关系
            - 只要有一边是数值，转成数值
        - 逻辑
            - 转布尔
- 强制：主动转换，可以拿到转换结果
    - 字符转数值
        - `parseInt(要转换的字符)`
            - 将字符转成整数，从左向右依次检测，能转则转，不能转，则停，第一位不能转，直接NaN，不识别小数点
        - `parseFloat(要转换的字符)`
            - 将字符转成小数，从左向右依次检测，能转则转，不能转，则停，第一位不能转，直接NaN
        - `Math.round(要转换的字符)`
            - 不是专门做数据转换，处理数据的过程中，可以转换
            - 严格转换，不允许任何位置出现非数字的字符
            - 四舍五入取最近的整数
        - `Number(要转换的字符)`
            - 不是专门做数据转换，处理数据的过程中，可以转换
            - 严格转换，不允许任何位置出现非数字的字符
    - 数值转字符
        - `要转换的数值.toString()`
            - 直接转，没有规则
        - `要转换的数值.toFixed(n)`
            - 直接转，根据传入的数字，决定保留n为小数，不够的位数补零
        - `String()`
            - 不是专门做数据转换，处理数据的过程中，可以转换
            - 直接转，没有规则
    - 其他转布尔
        - `Boolean()`
            - 不是专门做数据转换，处理数据的过程中，可以转换
            - 数值：非0为true，0为false
            - 字符：非空为true，空为false
            - undefined，null，NaN，都是false
            - 对象，数组，函数，都是true

### js的三大特殊数据
1. null
2. undefined
3. NaN

## 程序的结构
1. 顺序结构
    - 代码或功能的执行顺序，自上而下，按照固定的流程依次执行
2. 选择（分支）结构
    - 根据不同的条件或时机，选择不同的功能或代码执行
3. 循环结构
    - 重复执行，为了避免死循环，需要在每次执行之前，做条件判断，继续执行或停止
    
### 选择（分支）结构
1. 实现
    - 分支语句
        - 单分支：if
            ```js
            if(条件){
                条件为true，执行代码
            }
            ```
        - 双分支：if-else
            ```js
            if(条件){
                条件为true，执行代码1
            }else{
                条件为false，执行代码2
            }
            ```
        - 多分支：switch
            ```js
            switch(要判断的值或变量){
                case 可能的值1:
                    执行代码1
                    break;
                case 可能的值2:
                    执行代码2
                    break;
                ...
                default:
                    以上条件都不符合，执行这里的代码
            }
            ```
            - 默认情况下，case语句判断成功后，就不再向下判断了，形成了穿透特性
                - 阻止穿透：break
2. 应用
    - 分支语句的嵌套

    - if和switch的区别
        - if语句更擅长判断范围
            - 有隐式类型转换
        - switch语句更擅长判断具体的值
            - 没有隐式类型转换

    - 隐式类型转换
        - if有
        - switch没有

3. 补充
    - 三目表达式
        - 条件 ? 值1 : 值2
        - `res = n<10 ? "0"+n : ""+n;`

    - 逻辑短路
        - `console.log( 2 || 3 )`
        - `console.log( 0 || undefined )`
        - `console.log( undefined || 0 )`

4. 注意
    - 单词别写错
    - 括号要配对
    - 条件的书写：多个条件之间，使用逻辑运算符连接
    - if-else-if-else...的缩写语法
    - 三目表达式的语法格式和应用场景
    - 逻辑短路利用了隐示类型转换和逻辑运算符
        - 注意语法和场景
    
### 循环的语句

- while
    ```js
        初始化计数器
        while(执行条件){
            要重复执行的代码
            改变计数器
        }
    ```
- do-while：无论如何都会至少执行一次
    ```js
        初始化计数器
        do{
            要重复执行的代码
            改变计数器
        }while(执行条件)
    ```
- for
    ```js
        for(循环的三要素：初始化计数器;执行条件;计数器的改变){
            要重复执行的代码
        }
    ```
#### 循环的简单应用

- 循环语句自身没有难度
- 要重复执行的内容
- 执行循环的条件
- 计数器改变的步长
- 单层循环

#### 循环的控制关键字
- 主动控制循环的执行
- 10包子：编号，0~9
    - 吃5个，饱了：提前结束
        - break：结束当前循环，后面没执行完的，都不再执行了
    - 吃5个，有XXX，丢掉，后面的继续吃：跳过
        - continue：跳过本次循环，继续执行，后面的次数

#### 死循环
- 无法通过自身控制结束的循环
- 消耗大量的内存，浪费性能，影响程序执行
- 但是，可以利用死循环的思想，配合循环的控制关键字，解决问题

#### 循环的嵌套

1. 嵌套

   - 两个套起来
   - 多行多列的计算结构

2. 规律

   - 外层循环控制行

   - 内层循环控制列

## 函数
### 函数的意义
    - 将组成某个功能的代码块封装起来，可以通过自身或行为执行
    - 存储的是功能，代码段
    - 函数自身有诸多便利性特点，为了方便使用功能
### 函数的特点
    - 忽略细节
    - 选择使用
    - 重复使用
### 函数的创建和执行
#### 创建
- 声明式：`function fn(){}`
	- function 声明关键字
	- fn 函数名
	- () 参数
	- {} 函数体，函数的功能
- 赋值式：`var fn = function(){}`
#### 执行
- 函数名();     立即执行，自动执行，不会等待
	- 配合行为执行（事件触发）
	   - 事件源.事件类型 = 函数;
	   - 如：`btn.onclick = fn`
	   - 如：`btn.onclick = function(){}`
	   - 等待行为触发，必然是将来执行，异步
### 函数的分类（写法）

- 有名函数：function fn(){}
	- 正常函数，无特殊情况
- 无名函数：function (){}
	- 不允许直接存在，只能作为值存在
		- 作为赋值式创建函数的**值**
		- 作为匿名函数的函数体
		- 作为事件处理函数
		- 作为参数（回调函数）
		- 作为返回值（闭包）
- 匿名函数：(function(){})()
	- 自动执行
	- 创建作用域
	- 参数在后面的小括号中传递
- 箭头函数
### 函数的参数

- 概念：函数的入口，负责数据的传递，影响函数内部功能的执行
- 函数定义时，接收参数：形参
- 函数执行时，发送参数：实参
- 实参和形参的关系：赋值关系
	- 形参类似于变量
	- 实参类似于数据
- 语法上，参数的数量没有限制。使用习惯上，参数最好不要太多
	- 参数之间用逗号隔开
- 实参和形参的对应关系：
    - 数量一致：一一对应
    - 形参多：多出来的形参是undefined
    - 实参多：多出来的实参找arguments
- 实参可以传入任何数据
    - 当传入另一个函数时，作为参数的函数，叫回调函数
### arguments的使用
- **函数内部**特有的对象变量，以数组的形式体现（伪数组）
- 用来保存当前函数执行时传入的所有实参
- 使用
	- 数组：索引+长度
		- 索引：从0开始
		- 长度：arguments.length
		- 中括号语法
		```js
		for(var i=0;i<arguments.length;i++){
			console.log(arguments[i]);
		}
		```



### 函数的应用
- 封装思想
	- 为什么要封装函数
	- 为什么要穿参
	- 为什么要处理参数
		- 默认值 
		- 类型
### 函数的返回值
1. 概念：函数的出口
2. 函数内部的关键字：return
    - 返回函数内部的数据（将数据通过出口，暴露到函数外面）
    - `return 数据`
3. return的功能
    - 返回值
    - 结束函数
        - 一个函数一次执行只能执行一个return
        - 但是，一个函数中可以写多个return
    - 没有return的函数，的返回值是，undefined
4. 返回值的位置
    - 返回到哪了：函数的执行位置

5. 返回值可以返回所有数据
    - 当一个函数，返回了另一个函数时，在这个函数的嵌套中，就形成了闭包

6. 返回值的应用场景
    - 功能函数，没有必要返回值
    - 处理数据的函数，可以有返回值
## 作用域

1. 概念：数据作用的区域，数据生效的区域

2. 作用域的分类
    - 全局作用域：没有属于任何一个函数
    - 局部作用域：属于某个函数的区域

3. 作用域的访问规则
    - 子可以拿父
    - 父不能拿子

4. 变量的划分
    - 全局作用域下的变量（函数），叫全局变量（函数）
    - 局部作用域下的变量（函数），叫局部变量（函数）
        - 函数的形参，是当前函数的局部变量

5. 生命周期
    - 全局：跟随程序，一直存在与内存中，随时可以拿到
        - 方便
        - 占内存
    - 局部：跟随当前作用域，作用域开始的位置，被创建，作用域结束，被删除
        - 使用不方便
        - 省空间
    - 折中用法：
        - 利用匿名函数生成独立作用域，在匿名函数中进行功能开发

6. 变量的读写规则（拓展）
    - 写：
        - 先在当前作用域查找，当前作用域有，直接写，如果当前作用域没有，向上级作用域查找，直到全局，找到了，修改全局，没找到，定义成全局，再修改。（非严格模式）
    - 读：
        - 先在当前作用域查找，当前作用域有，直接使用，如果当前作用域没有，向上级作用域查找，直到全局，找到了，使用，没找到，报错。
### js的执行机制
1. js一门**解释型**的脚本语言
    - js会先通读全文，找到特定内容，提前解释（预解析，预编译）
        - 提前解释
            - 变量和函数的声明
    - 再执行解释之后的代码

2. 提前解释（预解析，预编译）
    - 变量(使用var声明的变量)
        - var声明变量的预解析（var的提升）
            - 提前声明：作用域最开始的位置
            - 原位赋值
    - 函数
        - function的整体提升，提前声明，并定义
    - 当var遇到function
        - 赋值式创建函数
            - 提升的是var的声明，function并没有提升
        - 当var的变量和function的函数名重名
            - 都提升
            - var提升的更高
            - 所以function生效

            - 本质：var会提升，在内存中声明了一个区域，function没有提升，直接使用这个区域

        - **避免变量名的重复！！！**
##   递归

1. 递归介绍
    - 在函数内部，执行自己
    - 死循环
    - 利用递归的思想，解决问题
    - 但毕竟有隐患，慎用！

2. 递归的过程（原理）
    - 递：向内执行，向内调用
    - 归：向外返回，向外结束
    - 终止条件：结束递，向外归

3. 电影院找座位
    - 递归公式
    - fn(当前的座位) = fn(当前的座位-1) + 1

4. 递归计算`5*4*3*2*1`
    ```txt
    5!
    5 * 4!
        4 * 3!
            3 * 2!
                2 * 1!
                    1
    ```
    - 假设，有一个函数fn，专门用来计算阶乘，用来计算n的阶乘
    - fn(n) = n * fn(n-1)
    - fn(1) = 1
        - 递的终点，归的起点
    - 实现fn计算阶乘的功能

5. 递归计算数列的第n位是多少：1,1,2,3,5,8,13,21,34,.....
    - 从第三位开始，每一位是前两位的和
    
    - 假设，有一个函数fn，专门用来计算数列的第n位
    
    - fn(n) = fn(n-1) + fn(n-2)
    
    - fn(1) = 1 || fn(2) = 1
      
        - 递的终点，归的起点
        
    - 实现fn计算数列的第n位的功能
## 数组
### 概念
- 数据的组合
- 数据的集合，类似于对象，但是没有键，只有索引
### 数组或对象的应用场景
- 单需要操作多个数据时，程序只支持一个
### 数组的创建
- 字面量
	- var arr=[];
- 构造函数
	- avr arr = new Array();
- 当只有一个数字类型数据时，字面量就是一个数据，构造函数会解析成长度
### 数组的使用
- 索引+长度
- 方法，功能，某个对象的功能，属于某个对象的函数
	- push		最后新增（可添加多个参数）返回值是新数组长度
	- unshift	开始新增（可添加多个参数）返回值是新数组长度
	- pop		最后删除（无参数）返回值是最后一次删除的数据
	- shift		开始删除（无参数）返回值是最后一次删除的数据
	- slice		截取（截取参数1~2的数据，返回新数组，包前不包后）
	- splice	删除并替换（参数1：删除的起始位置，参数2：要删除的个数，参数3：替换的数据）返回值是删除的数据
	- join		转字符（将字符变成字符串输出，参数时链接符，默认逗号）
	- concat	合并（要合并的数组）
	- reverse	翻转（无参数）
	- sort		排序（返回一个函数a-b从小到大，b-a从大到小）
### 数组的分类
- 数组中可以放任何数据，甚至可以放简单表达式
    - 当一个数组中的数据，全是字符时，叫字符数组
    - 当一个数组中的数据，全是数值时，叫数值数组
    - 当一个数组中的数据，全是数组时，叫数组数组（二维数组，**多维数组**）
        - 访问方式
            - 逐层解析数组
    - 当一个数组中的数据，全是对象时，叫对象数组（**json数组**）
        - 访问方式
            - 逐层解析数组和对象
### json
- json独立的通用数据，与任何编程语言无关，只是因为其格式参考了js的对象
- 所以，在js中有时也将对象成为json
- 所以，全是对象的数组，也可以称为json数组
### 基本数据和复杂数据
- 基本数据：string、number、boolean、undefined、null
	- 值传递，的数据
- 复杂数据
	- 引用传递，的数据
### 内存中的空间划分 栈堆
- 内存中的内存颗粒可分为
	- 栈：基本数据，复杂数据的地址
		- 变量名，空间小，稳定，不可修改
		- 先进后出
	- 堆：复杂的数据结构
		- 数据，空间大，可被修改
		- 先进先出
	- 关系
		- 一栈对一堆
		- 一栈对多堆
		- 不能多对一
### 值传递和引用
- 传递：复制
- 值传递：复制的就是值（基本数据）
- 引用传递：引用就是地址，复制的是地址，不是值（复杂数据）
	- 浅拷贝：只复制复杂数据的地址，不是值，修改新数据，影响老数据
		```js
			var obj = {name:"admin"};
			var obj2 = obj;
			// 将obj复制给了obj2，其实只是将obj的引用(地址)复制给了obj2，obj和obj2中保存的是同一份地址，指向的是同一个值，修改其中一个，影响另外一个
			obj2.name="张三";
			console.log(obj);
			console.log(obj2);
		```
	- 深拷贝：复制值，修改新数据，不会影响老数据
		- 先解析，在拷贝
			- 对象的解析拷贝（深拷贝）
            ```js
             var obj = {a:10;b:20;c:30};
                var obj2 = {};
                //for-in 解析
                for(var i in obj){
                obj2[i] = obj[i];
                }
                obj2.a = "666";
                console.log(obj);
                console.log(obj2);
            ```
        
      - 数组的解析拷贝（深拷贝）
            ```js
                var arr = [3,4,5];
                var arr2 = [];
                // 循环解析
                for(var i=0;i<arr.length;i++){
                arr2[i] = arr[i];
                }
                arr2[1] = "hello";
                console.log(arr)
                console.log(arr2)
            ```
## 字符串
- 万物皆对象
	- 对象才是构成js世界的本质
- 字符串也可以作为对象使用
### 创建字符
- 字面量
	- var str = "";
- 构造函数
	- var str = new String();
	- 只要是构建函数方式创造的，其结果必然是对象
	- new String()得到字符的对象
		- 长得先对象，但是可以作为正常字符使用
### 字符串的方法
- （类似于数组的操作）
- 索引加长度（index+length）
- 方法（字符串的方法都不改变原数据）
	- indexOF	**查询单个字符的索引**
		- 功能：查询字符串中单个字符的索引，如有重复，返回第一个
		- 参数：2个 1，要查询的字符；2，开始查询的位置
		- 返回值：该数据的索引，没查询到返回-1
	- lastindexOf	**反向查询单个字符的索引**
		- 功能：查询字符串中单个字符的索引，如有重复，返回第一个
		- 参数：2个 1，要查询的字符；2，反向开始查询的位置
		- 返回值：该数据的索引，没查询到返回-1
	- charAt	**根据索引查询数据**
		- 功能：根据索引查询字符串的数据
		- 参数：字符串的索引
		- 返回值：该索引对应的值，索引超出返回空字符串`""`
	- slice		**截取（包前不包后）**
		- 功能：截取指定的区域的字符
		- 参数：2个 1，开始的区域；2，截至的区域（可以负数，表示倒着截取）参数1为负数时表示长度减去参数1，参数2比这个值大就行
		- 返回值：返回截取的字符（包前不包后）
	- substr	**截取索引对应的值（截取多长写多长）**
		- 功能：截取指定区域的字符
		- 参数：2个 1，开始的索引；，2，要截取的长度
			- 当一个参数为负数时，只有一个参数，表示倒着截取参数的长度
		- 返回值：返回截取的字符
	- substring		**截取指定区域的数据（包前不包后）**
		- 功能：截取指定区域的字符串
		- 参数：2个 1，开始索引；2，结束索引
		- 返回值：截取的字符串
		- 参数大的是结束位置
	- replace	**替换**
		- 功能：替换指定的字符，只替换一次
		- 参数：2个 1，想要替换的字符；2，替换的字符
		- 返回值：替换之后的字符串
	- split		**分割（转数组）**
		- 功能：分割字符串形成数组
		- 参数：2个 1，以哪个字符作为分割点，并删除该字符；
				- 2，（可忽略）当1参数在字符串中存在多个，2参数决定要显示几个
				- 当参数为""时，一个字符一个分割
		- 返回值：返回分割后的数组
### 字符串的拼接
- 引号要配对，单双引号的嵌套要交替
- 被单双引号包裹的字符不允许换行
### 字符编码
- Unicode:万国码，所有字符都可以转成万国码
- Unicode时以四位十六进制的形式表示的（前缀\u）
	- 必须用\u作为前缀，此十六进制才是Unicode编码
- Unicode和字符的转换
	- 字符转成十进制，此十进制时由Unicode的十六进制转换得来的
		- String.fromCharCode(十进制或十六进制)
			- 参数可以是十进制
			- 参数可以是十六进制（"0x"开头）
			- 转换结果时字符
		- str.charCodeAt(索引)
			- 转换结果是十进制，这个十进制转成十六进制后，加上\u就是Unicode编码 
## 进制的转换
- 十进制转其他-（数值转字符）
	- num.toString(2||8||16)
	- 要转成几进制就写几
- 其他转十进制-（字符转数值）
	- parseInt(num,2||8||16)
	- num是几进制就写几
- 其他转其他
	- 二进制转八进制
	- 先转十进制，再转其他


# ES5的新增
## ES5：
- ECMAScript 5
## 严格模式
- 在ES5中，新增了一种编写代码的模式：严格模式
- 为了消除代码中的不合理，不严谨和隐患之处
- 体现了更好的发展方向
- 提升了代码的执行率
## 如何开启
- 在作用域的第一行放置一行字符串："use strict"
- 配合匿名函数，开启**伪全局**严格模式
## 开启严格模式的变更
- 变量必须先声明后使用
- 函数的形参不允许重复
- 函数的arguments保存实参，不会受到形参的改变而影响
- 函数的arguments不允许使用callee（会严格模式下arguments.callee是函数自身）
- 没有明确隶属对的函数的this，不指向window，指向undefined
- 0开头的8进制被禁止了
- with语句被禁止使用
- ...
## 数组的排序
- sort：简单排序（数值，字符，不能排对象）
- 自定义功能：自定义实现
- 排序算法
	- 比较规则：比较大小
	- 提升程序的执行性能，让程序更稳定
- 冒泡排序：
	- 原理：拿到数组的内一个数据，两两比较，大的放前面（后面）
	- ```js
		var arr = [5,4,3,2,1];
            console.log(arr);       // 排序之前
            // 比较次数的结构：多行多列
            // 0-1,1-2,2-3,3-4      length-1 - 0行 次
            // 0-1,1-2,2-3          length-1 - 1行 次
            // 0-1,1-2              length-1 - 2行 次
            // 0-1                  length-1 - 3行 次
        // 行：arr.length-1 次
    
            // 控制一共经过几轮比较，每轮比较，会得到一个最大值，放在了最后
            for(var i=0;i<arr.length-1;i++){
                // 确定每轮比较时，要比较哪些数据，因为上一轮会确定一个最大值，放在了最后，所以，每新的一轮比较，都可以比上一轮少比一次
                for(var j=0;j<arr.length-1-i;j++){
                    // 比较
                    if(arr[j] > arr[j+1]){
                        // 交换
                        var ls = arr[j];
                        arr[j] = arr[j+1];
                        arr[j+1] = ls;
                    }
                }
            }
            console.log(arr);       // 排序之后
    ```
- 选择排序：
	- 原理：拿到数组的每一个数，从左向右依次使用每一个数据，和前面所有的数据比较得到最小的，交换
	- ```js
	  var arr = [1,3,5,4,2];
    
            // 冒泡，每次比较都有可能交换一次，交互意味着在操作数组
            // 0-1,1-2,2-3,3-4
            
        // 选择，每次比较，绝对不交换，只是在记录最小值，一轮结束后，再做交换，将最小值和第一位交换
    
            // 比较次数的结构：多行多列
            // 0-1,0-2,0-3,0-4      0行~length-1
            // 1-2,1-3,1-4          1行~length-1
            // 2-3,2-4              2行~length-1
            // 3-4                  3行~length-1
        // 行：length-1   4 次
    
            for(var i=0;i<arr.length-1;i++){
                // 每轮开始之前，将当前位数据保存到临时变量，同时存储索引
                // 假设这个临时变量中保存的是最小值
                var min = arr[i];
                var minIndex = i;
                for(var j=i+1;j<arr.length;j++){
                    // 验证,临时变量中保存的是否是最小值
                    if(min > arr[j]){
                        // 修改临时变量,让他保存真正的最小值
                        min = arr[j];
                        // 同时记录最小值的索引
                        minIndex = j;
                    }
                }
                // 一轮结束后,交换数组中的数据
                // 一定要先将当前位数据,放在最小值的位置
                arr[minIndex] = arr[i];
                // 再将最小值,放在当前位
                arr[i] = min;
            }
            console.log(arr);
	  ```
## ES5新增数组的方法
- 方法：属于某个对象的函数
- 数组的方法
	- indexOf	**查询数组中数据所在的位置**
		- 功能：查询数据所对应的索引
		- 参数：1，要查询的数据；2，从哪个索引开始查询（可省略）
		- 返回值:数据的索引
			- 没有查询到数据：返回-1
			- 重复的数据：返回第一次出现的索引
		- 是否改变原数据：否
	- forEach	**遍历数组，得到数组的数据，索引，数组自身**
		- 功能：遍历数组
		- 参数：函数，函数有三个参数 1，数据；2，索引；3，数组自身；
		- 返回值：undefined（没有返回值）
		- 是否改变原数据：否
	- map	**批量操作数组数据（都+10）**
		- 功能：1，遍历数组（同forEach）2，返回一个新数组，可实现数组的深拷贝
		- 参数：函数，函数有三个参数 1，数据；2，索引；3，数组自身
			- 函数可有return，返回自己需要的数据
		- 返回值：返回一个新的数组，回调函数每执行一次就返回一个值
		- 是否改变原数据：否
	- filter	**判断数组中是否有符合条件的数据（>5）**
		- 功能：1，遍历数组（同forEach）2，过滤数组，返回一个新数组
		- 参数：函数，函数有三个参数 1，数据；2，索引；3，数组自身
			- 函数可有return，返回结果为true的数据
		- 返回值：返回一个新数组，回调函数每执行一次，返回一个结果为true的数据
		- 是否改变原数据：否
	- some	**判断数组中是否有某个数据（是否有10）**
		- 功能：1，遍历数组（同forEach）2，根据条件查询，返回布尔值，一个是true最终结果就是true
		- 参数：函数，函数有三个参数 1，数据；2，索引；3，数组自身
			- 函数有return，返回值为布尔值
		- 返回值：布尔值，作为参数的函数的返回值只要有一次是true最终结果就是true
		- 是否改变原数据：否
	- every	**怕不断数组的数据是否为同一类型**
		- 功能：1，遍历数组（同forEach）2，根据条件查询，得到布尔值，全部为true最终结果才是ture
		- 参数：函数，函数有三个参数 1，数据；2，索引；3，数组自身
			- 函数有return，返回值为布尔值
		- 返回值：返回布尔值，作为参数的函数的返回值全部是true最终结果才是true
		- 是否改变原数据：否
	- reduce	**快速求和**
		- 功能：1，遍历函数（同forEach）2，并归
		- 参数：两个
			- 一，函数，函数有4个参数，
				- 1，执行第一遍时：reduce的第二个函数，或数组的第一个数据
					第二遍以后：之前执行时的返回值
				- 2，数组的数据
				- 3，索引
				- 4，数组自身
			- 二，任意数据（可省略）
		- 返回值：回调函数最后一次执行法官的返回值
		- 是否改变原数据：否
	- reduceRight
		
		- 与reduce相同，从右开始
## 函数的方法
- 函数的函数，将函数作为对象使用他身上的方法
- 函数的方法
	- bind	**改变this指向，返回函数**
		- 功能：改变this的指向，返回了改变之后的函数
		- 参数：不限
			- 参数1：要改变的this指向
			- 参数2+：会传入原函数，作为原函数的参数
		- 返回值：修改this或参数后的新函数
	- call	**改变this指向，自动执行，返回原函数返回值**
		- 功能：改变this的指向后，自动执行改变后的函数
		- 参数：不限
			- 参数1：要改变的this的指向
			- 参数2+：传入原函数作为原函数的参数
		- 返回值：原函数的返回值
	- apply	**改变this指向，自动执行，返回原函数返回值**
		- 功能：改变this指向之后，置动执行改变之后的函数
		- 参数：2个
			- 参数1：要改变的this的指向
			- 参数2：数组，会传入原函数覆盖原函数的arguments
		- 返回值：原函数的返回值
- 函数方法的区别：
	- bind会修改之后的新函数（不会自动执行修改后的新函数），call和apply反之
	- bind和call可以接受多个参数，从第二个开始，都会传入修改之后的新函数作为参数。
	- apply只能接受两个参数，第二个参数是数组，会传入修改之后的新函数，自动解析后，作为arguments的内容





## this
- 当前函数的**执行**对象
	- 关键字，表示一个指向，只有在函数执行时才有，必须指向对象
- this的绑定方法
	- 默认绑定
		- window，没有明确隶属对象的执行执行（非严格模式）
	- 隐式绑定
		- 通过某个对象执行函数，this就是这个对象
		- 存在隐式丢失
			- 作为回调函数传入另一个函数中执行，this指向window
	- 强制绑定
		- 通过bind，call，apply绑定this指向，this指向设置值
	- new绑定
		- 通过new执行函数，this指向new出来的函数
- 改变this的指向 - 锦上添花
	- 任何情况下多可以不该变，改变之后能更方便
	- 案例：事件委托的封装

## JSON
- JSON，类似与文本文件的数据，前后端通用的数据文件（.json）
	- xml是以前的通用数据
- JSON并不属于任何一个语言，自身是一种独立的通用数据，只是在创建之初，参考了js的对象的格式
- JSON的语法
	- 必须符合js中的对象的基本要求
	- json的key必须加双引号
	- json不允许出现没有意义的逗号
	- json中不允许出现 函数、undefined、NaN
	- json在任何编程语言中都是以字符型数据体现，json文件中可以直接存在
- js中的json
	- 对象转json：要转换的数据必须符合对象要求
		- JSON.stringify(obj)
		- NaN转null
		- 不识别undefined，function(){}
	- json转对象：要转换的数据必须符合json的要求
		- JSON.parse(str)



# 对象
## 对象的概念
- 是复杂数据类型的一种，是一种数据集合
- 单个对象中只存放某类，有某种关系的数据
- 对象在显示生活中，一般用来描述事物
## 对象的语法
- 属性名：属性值
- 键值对（key：value）
- 对象的标志是花括号{}
## 对象的创建
- 字面量
	- var obj = {name："anmin"}
- 构造函数：批量
	- var obj = new Object（）；
## 对象的使用
- 点语法
    ```js
        var obj = {};
        obj.name = "admin";
        console.log(obj.name);
    ```
- 中括号语法
    ```js
        var obj = {name:"0"};
        obj["name"]="admin";
        var str = "name";
        console,log(obj[str]);
    ```
## 对象的组成和意义
- 组成：键值对
- 意义：存储数据编程
## 关系
- 任何两个对象都不相等
- 如果相等了，就是一个对象 
## 对象的分类
- 本地对象（构造函数）
	- 创建字符的对象：String
	- 创建数值的对象：Number
	- ...
	- 创建日期的对象：Data
	- 创建正则的对象：RegExp
	- ...
	- 被new 执行之后，才能得到对应的对象
	- 内置构造函数
- 内置对象
	- 可以直接被使用的对象，不需要创建和操作
	- 数学对象：Math
- 宿主对象
	- 没有明确隶属对象的数据（变量，函数），就属于window 
	- window是客户端js中的顶层对象，客户端中最大的boss
	- 一般情况下，window可以被省略
		- 特殊情况：
			- 严格模式
			- 在局部声明全局（window.a = 10;）
## this
- 关键字，类似于变量，但并不是变量，是一个指向（指针），它的支持按必然是一个对象烈性的数据（不是对象强转对象）
- 一般存在于函数中
	- 不在任何函数中的this，指向window
- this在函数中默认是没有指向的。只有在函数执行的一瞬间，才有指向
- this指向当前所在函数的**执行对象**（函数被哪个对象执行，就指向哪个对象）
	- 默认执行
		- 函数名()
		- this指向window
	- 对象执行（事件）
		- 对象.函数()
		- this指向对象
	- 作为回调函数使用
		- 参数()
		- this指向window
	- new 执行
		- new 函数()
		- this指向new出来的对象
- 误解1：this是当前函数，×				   函数的指向
- 误解2：this在哪被定义，就是谁，×			被谁执行接指向谁
- 误解3：this是变量，×						关键字
## 对象的操作
- 删除对象的属性
	- 关键字：delete 对象.属性名
	- 最好清空 对象.属性名 = null
## 内置对象
- Math 是数学对象，提供了数学操作
	- 方法
		- Math.round(数字)               四舍五入
		- Math.random()			   	 随机数
		- Math.abs(数字)			  	 绝对值
		- Math.ceil(数字)			   	 向上取整（取大的）
		- Math.floor(数字)			       线下取整（取小的）
		- Math.min(数字1，...)		   最小值（不能放数组NaN）
		- Math.max(数字1，...)		   最大值（不能放数组NaN）
		- Math.sqrt(数字)			    	根号下
		- Math.pow(数字，几次方)     几次幂
	- 属性
		
		- Math.PI				                 圆周率
## 本地对象
- Date（需要new之后才能使用）
- 创建日期对象
	- new Date()
- 获取日期
	- get系列方法
		- getFullYear()			年
		- getMonth()			月0~11
		- getDate()				日
		- getDay()				星期0~6
		- getHours()			时
		- getminutes()			分
		- getSeconds()			秒
		- getMilliseconds()		毫秒（100毫秒==1秒）
		- getTime()				获取时间戳（1970年1月1日0：0：0到此时的毫秒）
- 获取指定日期
	- 给构造函数传参
		- 一个参数（字符）
			- 没设置的部分：清0；超出的日期：Invalid Data；月份从1开始
		- 多个参数（数值）
			- 没设置的部分：清0；超出的日期：向前进1；月份从0开始
	- 创建函数后，修改日期
		- 逐部分修改
			- 没设置的部分：以当前日期为准；超出的日期：向前进1；月份从0开始
			- set系列方法
		- 设置时间戳
			- 设置从1970年1月1日0：0：0过去了的毫秒数
			- 日期对象.setTime(毫秒数)
	- 计算两个日期的时间差
		- 设置两个指定的日期
		- 将日期对象相减，得到毫秒数（兼容问题）
		- 先获取日期对象的时间戳，在相减，得到毫秒数，转换（没有兼容问题）
# BOM
## BOM的介绍
- 浏览器的对象模型：window
- 提供了窗口与窗口之间的通信
- 用户与浏览器的交互
- 浏览器自身的信息
## BOM和DOM和ECMAScript的关系
- BOM：提供运行平台
- DOM：书觉得体现，传达各种视觉信息
- ECMAScript：规定了如何在BOM中操作DOM，操作DOM在BOM中显示除什么样的效果
- （ECMAScript规定了，准备让DOM以什么样的形式，在BOM中显示）
- ECMAScript和DOM都时运行在浏览器中，所以，除了需要遵守自己的规定以外，还要遵守浏览器（BOM）的规定
- DOM的对象document，也属于window
## BOM-window
- window是js的顶层对象，涵盖了介绍所有的信息
- window有自己的方法（内置的全局函数）
- window有自己的事件
- window有自己的子对象（内置的全局对象）
- window有自己的属性（内置的全局变量）
## window的方法
- 全局函数
	- parseInt()
	- isNaN()
	- ...
	- open(url)打开新窗口
		- 直接使用会被当做广告拦截
	- close()关闭当前窗口
	- 弹出框三兄弟
		- alert()		弹出信息框；无返回值
		- prompt()		弹出输入框；返回输入的值，没有输入返回空字符
		- confirm()		弹出选择框；点击确定返回true，取消返回false
	- 定时器
		- 计时器
			- 开（重复执行）
				- setlInterval(参数1,参数2)
				- 参数1：函数
				- 参数2：毫秒数
			- 关（清除计数器）
				- clearInterval(参数)
					- 参数：要清除的计时器的唯一标志（返回值变量）
		- 延时器
			- 开（延迟执行）
				- setTimeout(参数1,参数2)
					- 参数1：函数
					- 参数2：毫秒数
			- 关（清除延时器）
				- clearTimeout(参数)
					- 参数：要清除延时器的唯一标志（返回值变量）
## window的事件
- load
	- **结构**和**资源**都加载结束
- resize
	- 可视区域的尺寸
		- document.documentElement.clienWidth//可视区域的宽度
		- document.documentElement.clienHight//可视区域的高度
- scroll
	- 滚走的距离
		- document.documentElement.scrollTop//滚动条距离右边的距离
		- document.documentElement.scrollLeft//滚动条距离左边的距离
		- （高频事件可能不会被浏览器快速捕捉，正常现象）
## window的子对象
- location：浏览器的地址栏，url
	- herf：浏览器的完整地址
		- 可获取，可设置。设置后页面会跳转
	- search：地址栏?后的部分，表示数据查询（要向后台发送的数据）
		- 可获取，可设置。设置后页面会跳转
	- hash：地址蓝#后的部分，表示锚点链接（哈希值）
		- 可获取，可设置。设置后页面会跳转
	- reload()：重新加载，刷新当前页面
	- assign(url)：跳转到指定地址，url为字符类型数据，空字符，刷新
- history：历史记录，浏览器的前进后退键
	- length：历史记录的个数
	- forward()：向前一个历史记录
	- back()；向后一个历史记录
	- go(n)：正：向前走；负：先后退；0：刷新
- navigator：浏览器信息
	- userAgent：浏览器信息（名，内核，版本，运行系统）
- screen：视口，屏幕尺寸
- frames：框架，对应iframes的标签操作
- document：文档对象，网页
### 页面刷新的方法
- location.reload()
- location.assign("")
- history.go(0)
- location.href = lication.href
- location.search = location.search
- location.hash = location.hash

# DOM
## 介绍
- DOM：文档对象模型：document
- document，网页，document其实就是网页的抽象
- 提供了所有网页的操作
- DOM结构，参照html结构
	- 倒树形结构，家族结构
- DOM的所有组成成分都叫节点，所有的节点都是对象类型
	- 元素节点（标签）
	- 文本节点（标签内的文字）
	- 注释节点（注释）
	- 属性节点（属性）
	- 根节点（根元素）
- js做行为，先选中要控制的元素（选择器），交互（样式，属性，元素，内容）
## 选择器
- 元素节点选择器
	- 直接选择
		- id（id名）
			- document.getElementById("id名");
			- 单个对象，失明特性（多个id只选择第一个）换hi对象
		- class（class名）
			- document.getElementsByClassName("class名");
			- 多个对象，返回数组，一个元素返回也是数组
		- tagName（标签名）
			- document.getElementsByTagNamr("标签名");
			- 多个对象，返回数组，
		- name（name属性，表单类）
			- document.getElementsByName("name属性值")；
			- 多个对象，返回数组
		- query（css写法）单个
			- document.querySelector("css选择器");
			- 单个对象，支持css的所有写法，返回对象
		- queryAll（css写法）多个
			- document.querySelectorAll("css选择器");
			- 多个对象，支持css所有写法，返回数组
	- 关系选择
		- 父选子元素
			- 父选子元素节点 		ele.children
			- 子选父元素节点 		ele.parentNode
			- 兄元素节点			 ele.previousElementSibling
			- 弟元素节点			 ele.nextElementSibling
			- 第一个子元素节点	    ele.firstElementChild
			- 最后一个子元素节点	   ele.lastElementChild
- 其他节点选择器
	- 关系选择（没有子选父）
		- 父选子节点			ele.childNodes
		- 兄节点			 ele.previousSibling
		- 弟节点			 ele.nextSibling
		- 第一个子节点	   ele.firstChild
		- 最后一个子节点	  ele.lastChild
	- 属性选择
		- ele.attributes（数组）
	- 伪数组
		- 可以有索引，可以有长度
		- 不能使用数组的方法（push...）
- 选中之后的内容
	- 单个对象：可以直接使用
		- id（id名）
		- query（css写法）
		- parentElementNode（子选父元素节点）
		- previousElementSibling（兄元素节点）
		- nextElementSibling（弟元素节点）
		- firstElementChild（第一个子元素节点）
		- lastElementChild（最后一个子元素节点）
		- previousSibling（兄元素节点）
		- nextSibling（弟元素节点）
		- firstChild（第一个子节点）
		- lastChild（最后一个子节点）
	- 数组：解析数据后才可以使用
		- className（class名）
		- tagName（标签名）
		- name（name属性，表单类）
		- queryALL（css写法）
		- childred（父选子元素节点）
		- childNodes（父选子节点）
		- attributes（属性节点）
## 节点的过滤
- 节点的信息属性
	- 节点.nodeType		类型
	- 节点.nodeName		名字
	- 节点.nodeValue		内容
|节点|类型nodeType|名字nodeName|内容nodeValue|
|-|-|-|-|
|元素|1|标签名（大写）|null|
|文本|3|#text|文本内容|
|注释|8|#commen|注释内容|
|属性|2|属性名|属性值|
|跟|9|#document|null|
## 样式
- 行内样式**用来设置**
	- 获取：元素.style.css属性
		- 只可以获取行内，鲁能获取非行内
	- 设置：元素.style.css属性 = "值"
		- 元素.style.cssText 可以重新设置所有样式
	- 没有兼容，所有浏览器都支持
	- 计算设置样式，必须找行内操作
- 非行内样式**用来获取**
	- 不可以设置
	- 获取：getComputedStyle(元素，null).css属性名
		- 既可以获取非行内样式，也可以获取行内样式
		- 有兼容性（IE8几以下）
			
			- IE专属属性：元素.currentStyle.css属性名
		- 最终兼容处理
		- ```js
			function getStyle(ele,attr){
				if(ele.currentStyle){
					return ele.currentStyle[attr];
				}else{
					return ele.getComputedStyle(ele,null)[attr];
				}
			}
			```
## DOM元素属性
- html属性：可以写在html标签内的属性
	- 内置
		- class(className),id,title,alt...
		- 操作：
			- 对象的操作方式
			- 系列方法
				- 查
				- getAttribute()		一个参数，要获取的属性名
				- 增、改
				- setAttribute()		两个参数，要设置的属性名和属性值
				- 删
				- removeAttribute()		一个参数，要删除的属性
	- 自定义
		- 只要官方没有提供，强行写在html标签内的，都是自定义
		- 操作
		- 系列方法
			- 查（返回查询的数据）
			- getAttribute()		一个参数，要获取的属性名
			- 增、改（返回undefined）
			- setAttribute()		两个参数，要设置的属性名和属性值
			- 删（返回undefined）
			- removeAttribute()		一个参数，要删除的属性
- js属性：没有写在HTML的标签内
	- 内置
		- innerHTML(获取标签的内容，包括子元素，字符)
		- innerText(只获取文本内容，字符)
		- outerHTML(获取包括自己的标签内容，包括自己，子元素，字符)
		- tagName...
		- 操作
			- 对象的操作方式
	- 自定义
		- 只要官方没提供，强行写，都是自定义
		- 操作：
			- 对象的操作方式
	**本质上就是将元素作为对象使用**
## 元素的尺寸类属性
- offsetWidth/Height(内容+内边距+边框)
	- cont + padding + border
- clientWidth/Height(内容+内边距)
	- cont + padding
- scrollWidth/Height(内容+内边距+溢出内容)
	- cont + padding + 溢出内容
- offsetLeft/Top(相对于包含快的位置)
	- 相对于包含快的位置
- scrollLeft/Top(只有这个可以设置)
	- 滚走的距离（可以设置）
- 包含块
	- 距离当前元素最近的拥有定位的父元素，如果没有，就是根元素
	- 获取某个元素的根元素：元素.offsetParent
## 元素（标签）的操作
- 增：
	- 创建标签
		- createElement("标签名")
	- 插入标签
		- appendChild(创建的标签)
	- **每创建一个元素只可以插入一次**
- 删：
	- 元素名.remove()
	- 父元素.removeChild(子元素)
- 改：
	- 先使用innerHTML获取到不包括自己的内部所有内容
	- 替换包裹的标签后放入变量中
	- 使用outerHTML把原来的所有内容替换成新内容
	```js
		var onav = document.querySelector("nav");
		var str = "<span>"+ onav.innerHTML +"</span>";
		onav.outerHTML = str;
	```
- 查：选择器









# 事件
## 概念
- 事件，行为，用户和浏览器或页面交互的过程中发生的行为
- 根据用户的不同行为，执行不同的程序，响应事件
## 组成
- 元素.on事件类型 = 函数
	- 元素：绑定事件的元素，事件源
	- on：绑定事件的方式
	- 时间类型：行为类型
	- =：赋值，on绑定事件的方式所特有的部分
	- 函数：事件处理函数
## 事件类型的分类
- on是一种绑定事件的方式，并不属于事件分类的名字
### 1. 鼠标类
- 左键单击：click
- 左键双击：dblclick
- 右键单击：contextmenu
- 进入：mouseover（有冒泡） / mouseenter（无冒泡）
- 离开：mouseout （有冒泡）/ mouseleave（无冒泡）
- 移动：mousemove
- 按下：mousedown
- 抬起：mouseup

### 2. 键盘类
- 按下：keydown
- 抬起：keyup
- 按下并抬起：keypress

### 3. 表单类
- 失去焦点：blur
- 获取焦点：focus
- 输入：input
- 内容改变：change
- 提交：submit
- 重置：reset

### 4. 浏览器类
- 加载：load
- 改变大小：resize
- 滚动：scroll

### 事件的绑定语法
- `事件源.on事件名 = 函数`
	- `btn.onclick = function(){}`

- 注意：
    1. 注意当前行为
    2. 注意事件源
    3. 注意当前事件源，会不会触发当前行为
    4. 键盘事件不能加给不能被选中的元素
        - 表单控件
        - document
    5. ...

## 事件对象
- 自身是一个对象类型，事件按对象内，保存了当前这次事件发生过程中的相关信息
- 事件（上级安排任务，刺探敌情）
- 上级：计算机（浏览器）
- 如何完成任务：塑件类型
- 任务是什么：事件处理函数
- 秘书：帮助，记录信息，事件对象
### 事件对象的特点
- 每次事件都有不同的秘书（事件对象跟随事件变化）
- 只有事件对象发生时，才有秘书，没有事件，没有秘书（事件对象，依赖事件）
- 任务结束后，秘书会被回收（事件对象在事件结束后，被浏览器回收）
- 防止暴露信息，秘书日常隐藏，需要时主动召唤，才能使用（事件对象默认隐藏，需要主动使用）
### 如何获取事件对象
- 必须要有事件
- 只能在事件处理函数中才能获取到事件对象
	- 事件处理函数的第一个参数：正常浏览器
	- 找window对象身上的event：IE
	- 兼容写法
	```js
		ele.onclick = function(eve){
			var e = eve || window.event;
		}
	```
### 事件对象的属性
#### 鼠标事件的事件对象
- 当前鼠标触发事件时，在元素身上的坐标
	- 事件对象.属性
		- offsetX/Y
			- 鼠标相对于**事件目标**的坐标
		- clientX/Y
			- 鼠标相对于**可视区域**的坐标
		- pageX/Y
			- 鼠标相对于**页面**的坐标
		- screenX/Y
			- 鼠标相对与**显示器**的坐标
		- button
			- 左键：0；中键：1；右键：2；
		- buttons
			- 左键：1；中键：4；右键：2；
		- type
			- 事件类型
#### 键盘事件的对象
- 事件对象.属性
	- keyCode
		- 对应的按键
		- 有兼容
			- keyCode（IE）
			- which（其他）
			```js
				var k = e.keyCode || e.which
			```
	- ctrlKey
		
		- ctrl键
	- shiftKey
		
		- shift键
	- altKey
		
		- alt键（执行一次后焦点消失）
	- metaKey
		
		- win键
## 默认事件
- 概念
	- 浏览器自带的功能，文字的选中，右键菜单，tab的切换焦点，表单的提交跳转，a的提交跳转...
	- 阻止默认事件
		- 找到事件
		- 拿到事件对象
		- 阻止方法
		```js
			function stopDefault(e){
				if(e.preventDefault){
					e.preventDefault();
				}else{
					e.returnValue = false;
				}
			}
		```
- 阻止右键菜单
	- 找到事件源(document)右键事件
	- 拿到事件对象
	- 阻止


## 事件流

### 事件捕获
- 从外向内
- 如果需要事件捕获，需要配合专用语句实现
	- 监听式绑定事件
	- 下一知识点
### 事件目标
- 事件源
	
	- 绑定事件的元素，可以通过this获取
- 事件目标
	
	- 触发事件的元素，通过事件对象身上的属性：e.target / e.srcElement获取
- 事件源和事件目标的区分
	- 一般情况下，事件源就是事件目标
	- 当发生事件冒泡时，事件源与时间目标就不是同一个元素
	```html
		<body>

        <div class="box">
            <input type="button" value="我没有事件，但是可以点">
        </div>

    <script>

        var obox = document.querySelector(".box")

        obox.onclick = function(eve){
            var e = eve || window.event;
            var tar = e.target || e.srcElement;

            console.log("事件源是：", this);
            
            console.log("事件目标是：", tar);
        }

    </script>
    </body>
	```
### 事件冒泡
- 从里向外
- 事件的执行循序
- 浏览器默认情况下会使用事件冒泡的事件流
- **如不需要冒泡，阻止冒泡，不要设置成捕获**
	
	- 事件冒泡：当触发某个元素的某个事件时，该事件执行后，会**依次向上**触发**所有父元素**的**相同**事件
	- 按需阻止
		- 阻止方式
			- eve.stopPropagation();其他浏览器
			- eve.cancelBubble = true;IE浏览器
			- 兼容写法
			```js
				function stopBubble(e){
					if(e.stopPropagation){
						e.stopPropagation();
					}else{
						e.cancelBubble = true;
					}
				}
			```
    ```js
        e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
    ```
## 事件委托
- 概念
	- 利用**事件冒泡原理**，将绑定在**多个子元素**身上的**相同事件**绑定在页面上现存的**父元素**身上
- 特点
	- 节省性能
	- 可以给页面上暂时不存在的元素绑定事件

## 监听式绑定事件
### 赋值式绑定
- DOM0级事件绑定（on绑定）
- 元素.on元素类型 = 元素处理函数
	- `btn.onclick = function(){}`
- 没有兼容
- 无法重复绑定
	- 本质是赋值
	- 重复赋值会覆盖
### 监听式绑定事件
- DOM2级事件绑定
- 可以添加多个监听事件
- 有兼容
- 正常浏览器
	- 绑定事件监听
		- 元素.addEventListener("事件类型"，事件处理函数，布尔值)
		- `btn.addEventListener("click",function(){},false)`
            - false:事件冒泡，默认值
                - true：事件捕获
	- 解绑事件监听
		- 元素.removeEventListener("使劲按类型"，使劲按处理函数，布尔值)
		- `btn.removerEventListener("click",function(){},flase)`
		- **清除监听是采用给函数命名的方式创建函数**
- IE浏览器
	- IE浏览器只有冒泡，没有捕获
	- 当一个元素绑定多个相同事件后，先执行后绑定的
  - 绑定监听事件
        - 元素.attachEvent("on" + 事件类型，事件处理函数)
	          - `btn.attachEvent("onclick",function(){})`
	- 解绑监听事件
		- 元素.detachEvent("on" + 事件类型，事件处理函数)
		- `btn.detachEvent("onclick",function)`
- 监听式绑定事件的封装
    ```js
        function addEvent(ele,type,fun){
            if(ele.addEventListener){
                ele.addEventListener(type,fun,false);
            }else{
                ele.attachEvent("on"+type,fun)
            }
        }
    ```
- 监听式解绑事件的封装
	```js
		function removerEvent(ele,type,fun){
			if(ele.removeEventListener{
				ele.removeEventListener(type,fun,false);
			}else{
				ele.detachEvent("on" + type,fun)
			}
		}
	```
- **删除的事件处理函数，必须和绑定的事件处理函数是同一个**
	
  - 为了保证绑定和删除的时候是同一个函数，最好提前给这个函数起名
    - 通过函数名，找到该函数

# 函数的封装思想
## 入口和出口的处理
- 入口处理
	- 参数的处理
		- 默认参数的处理（考虑用户可能用到的情况）
- 出口的处理
	- 在数据处理完后，不要帮用户做更多的决定
	- 将处理好的数据，打包成通用数据，返回（数组或列表）

# 正则
## 介绍
- 正则：正确的规则，描述了字符串的规则，正则自身是一个**表达式**也可以作为**值**存在，这个字本身就是一个**对象类型**的数据，正则也被称为：**正则表达式，正则对象**
- 正则式用来造作字符串的
## 意义
- 验证字符
- 数量使用的情况下，极大的提高工作效率
- 从一串杂乱的字符串中取出所有的数字-原生js
	```js
		var str = "asd256asd834as5da38sd512zcacas";
        var linshi='';
        var arr=[];
        for(var i = 0; i < str.length; i++){
            if(str[i]>=0 && str[i]<=9){
                linshi += str[i];
            }else{
                if(linshi != ''){
                    arr.push(linshi)
                    linshi = '';
                }
            }
        }
        console.log(arr);
	```
- 从一串杂乱的字符串中取出所有的数字-正则表达式
	```js
		var str = "asd256asd834as5da38sd512zcacas";
        var arr = str.match(/\d+/g);
        console.log(arr);
	```
## 创建正则
- 正则的标志：//
- 字面量
	- var reg  = /正则内容/;
- 构造函数
	- var reg = new RegExp(变量，修饰符);
	- 变量的值必须是字符
## 正则的使用
- 正则的主要功能：**验证**test，**替换**replace，**查询**match
- 正则的方法
	- reg.test(str)：测试，验证（返回布尔值）
	- reg.exec(str)：查找
		- 将查询到的信息返回到数组里，数组包含多个信息
		- 每次只能查询一个
		- 属性lastindex是上一次查询完索引所在的位置
		- 查询到最后一次是返回null，下次从头开始查找
		- 在exec中()是要查询的子集，解析后放到数组中
	
- 字符的方法
	- srt.replace(reg,newStr)：替换，根据指定正则，替换成指定字符（返回替换之后的字符串，不该改变原字符串）
	- str.match(reg)：查找，符合正则的字符，放在一个数组中（返回数组）
	- str.search(reg)：查找
		- 数据第一次出现的索引
- test的默认验证规则
	- 只要被验证的字符串的局部，符合正则，就返回true
	- 如需整体验证，在正则开始时加^,结尾时加$
## 正则的符号
- 修饰符
	- `g`：全局匹配
	- `i`：忽略大小写
- 量词
	- `+`：表示1个或以上
	- `*`：表示0个或以上
	- `?`：表示0个或1个
	- `{n}`：表示指定n位
	- `{n,}`：表示至少n位，上不封顶
	- `{n,m}`：表示至少n位，至多m位
- 特殊字符
	- `|`：或
	- `()`；整合成一个部分
	- `[]`：中元符，表示一位，中元符内的内容时或的关系
	- `[^]`：表示非，除了中元符内的内容
- 转义字符
	- `\d`：表示所有的数字，等同于`[0-9]`
	- `\w`：表示字母数字下划线，等同于`[0-9a-zA-Z_]`
	- `\s`：表示空格，等同于` `
	- `\D`：表示非数字，等同于`[^0-9]`
	- `\W`：表示非字母数字下划线，等同于`[^0-9a-zA-Z_]`(特殊字符)
	- `\S`表示非空格，等同于`[^ ]`
	- `\`：表示转义符，将正则中有含义的符号，转成没含义的字符
- 通配符
	- `.`：通配符，表示所有
## 正则的读
- 根据写好的正则，读出规则，写出相应的字符
- 正则只能验证格式的合法，不能验证内容的合法
## 补充
- exec：每次只能查询一个，多次执行查询多个
	- lastindex，下一次查询的下标，可获取可设置
- search：查询符合正则的字符的索引
- match：全局查询下，将查询出来的数据放在数组中

# ES6
## 介绍
- ES6  就是ECMAScript 6（ECMAscript2015）
- 暂时没有得到所有浏览器的支持，但是所有浏览器的新版本都支持
## 声明变量的关键字
- let：声明变量
- const：声明变量（常量）
- class：声明类
- import：模块化中引入模块
- export：模块化中暴露模块
- let和var的区别
	- 没有提升
	- 不允许重复
	- 块级作用域
	- 全局变量不会绑定到window
	- 暂时性死区
- const与let的区别
	- let有的，const都有
	- const是常量，声明之后不允许被修改
		- 实质：const不允许修改的是地址，不是值
		- 注意复杂数据
- 如非特殊情况var全部换成let或const
## 解构赋值
- 是一种赋值方式，解构，解析结构
- 主要用来解构复杂数据
	- 对象
	- 按照键名一一对应，不存在的键是undefined
		```js
			let obj = {name:"admin",age:18,sex:"男"}
			let{name,age,sex,d} = obj;
		```
	- 数组
	- 按顺序一一对应，不存在的索引位置是undefined
		```js
			let arr = ["hi",123,true,{name:"a"},"hi"];
			let [a,b,c,d,e,f] = arr;
		```
	- 字符
	- 按顺序一一对应，不存在的索引位置是undefined
		```js
			let str = "hello";
			let [a,b,c,d,e,f] = str;
		```
- 巧用解构赋值
1. 快速交换两个变量的值
    ```js
    let a = 10;
    let b = 20;

    [b,a] = [a,b];

    console.log(a);
    console.log(b);
    ```
2. 快速解构函数的参数
    ```js
    function fn({name,age}){
    console.log(name)
    console.log(age)
    }
    fn({
    name:"admin",
    age:18
    })
    ```
    
3. 快速解构函数的返回值
    ```js
    function fn(){
    return {
    year:2020,
    month:8,
    date:28
    };
    }
    var {year,month,date} = fn();
    ```
## 字符的新增
- Unicode编码
	- 五位十六进制
	- \u{20bb6}
- 方法
	- 字符转u编码（新老版本通用）
		- str.codePointAt()
		- "𠮶".codePointAt()
	- u编码转字符（新老版本通用）
		- String.fromCodePoint(十进制/u编码)
		- String.fromCodePoint(134070)
	- 查询是否以指定字符开头
		- str.statrtsWith("查询的字符")
		- str.startsWith("e")
	- 查询是否以指定字符结尾
		- str.endsWith("查询的字符")
		- str.endsWith("l")
	- 查询是否包含
		- str.includes("查询的字符")
		- str.includes("s")
	- 重复字符
		- str.repeat(重复次数)
		- str.repeat(5)
- 拼接
	- 字符串模板
	- 支持反引号字符:
		```js
			let str = `hello`;
		```
	- 在反引号中支持：{$变量}
		- 支持简单表达式
		- 支持执行函数
		- 反引号中支持换行
## 函数
- 箭头函数：=>
- 类似于无名函数，只能作为值存在，不允许直接使用
- `()=>{}`
    ```js
		let fn = function(a){
			return "hello"+a;
		}
		console.log(fn("admin"));
		//箭头函数
		let fun a=>"hello"+a;
		console.log(fun("root"));
    ```
- 特点
	1. 极简 - 语法简单
	2. 当箭头函数的参数，有且仅有一个时，可以省略小括号 
	3. 当箭头函数的函数体，有且仅有返回值（返回值不是对象）时，可以省略花括号和return（只要省略了花括号自动将箭头后的内容返回）
	4. 当返回值是对象时如果省略花括号和return，需要用小括号将对象括起来
	5. 箭头函数没有自己的this，自动绑定上层的this
	6. 不能作为构造函数使用，不能new执行
	7. 极简 - 伤害代码的可读性（正则）
- 应用场景
	- 参数
	- 返回值
	- **不建议作为事件处理函数使用**
		- 没有this
## 展开运算符
- **...**
- 可以展开复杂数据
- 【注】展开位置，要在**能接收展开之后数据**的位置展开
## symbol类型

- shi

- 非常像字符，表示一个标记，记号
- 创建：let s = Symbol();
- 任何两个symbol都不相等
- 用来限制字典量的验证
	- 标记，记号，状态
- Symbol函数会生成一个唯一的值可以理解为Symbol类型跟字符串是接近的 但每次生成唯一的值，也就是每次都不相等，至于它等于多少，并不重要 这对于一些字典变量，比较有用
## 数据的集合 set和map
- 不是新的数据类型，还是对象，仅仅是数据的打包形式不一样
- 数组：数据的有序集合，索引0~length-1
- 对象：数据的无序集合，没有索引，键值对
- set：数据的无重复集合
	- 去重
	- new Set();
	- 没有索引
	- 键和值是同一个
	- 方法
        - add()添加的值
        - keys()键
        - values()值
        - enteries()键和值
- map：数据的无需集合，键值对，语法与对对象不同
	- new Map();
	- 键值对（name=>"admin"）
	- 方法
		- set()添加或修改值
		- keys()键
        - values()值
        - enteries()键和值

# 面向对象
## 理论
### 什么是面向对象
- 面向
	- 对着，面朝
	- 以...为主
- 对象
	- **信息打包之后形成对象**
		- 优势：
			- 提升信息的**查找速度**
			- 提升信息的**传输速度**
		- 对象被创建后被创建后如需要批量赋值，造成信息的冗余
			- 先将对象抽象化，**抽象成类**
			- 在根据特性的不同，将类中的抽象**具象化出对象**
			- 根据特性的不同，将类中的抽象划分成：**属性和方法**
				- 属性会随着具体的对象而变化
				- 方法不会随着具体的对象变化
		- **同一个类创建的对象，可能具有同一个方法**
- 面向对象（OO）- **大规模的分工，紧密的协作**
	- OOA：面向对象的分析
		- 将需求不断地细节化，不断地拆分，拆分成能直接实现的需求
	- OOD：面向对象的设计 - **高内聚，低耦合**
		- 将拆分后的需求，使用分工协作的方式搭建结构
		- 每个需求之间都会有千丝万缕的关系
- 面向对象和面向过程的区别
	- 面向对象：
		- **功能化编程，只关注结果，不关注过程**
	- 面向过程：
		- **不关注功能，只关注过程和结果**
### 面向对象编程的特点
- **封装：比函数更大的封装**
- **继承：从父类继承出子类**
- **多态：对象的多种形态**
## 语法
### 面向对象的语法
- **OOP：面向对象编程**
- 填充具体的实例，编程
- 创建对象
	- 字面量（单体/单例对象）：
		
		- var obj = {}；
	- 构造函数：
		- 构造内置函数：new Object();
		- **构造自定义函数**：new Fn();
			- 构造函数的命名方式采用大驼峰（首字母大写）
			- 构造自定义函数创建对象，属于内置的工厂模式
			```js
  		function CreatePeople(n,a,s){
                this.name = n;
                this.sex = s;
                this.age = a;
                this.say = function(){
                console.log(this.name);
            }
            }
            var p1 = new CreatePeople("张三",18,"1");
            console.log(p1);
	          p1.say();
			```
- 面向对象的思想
	- 抽象
	- 属性
	- 功能继承
## new的原理
1. 创建了一个新对象
2. 将原函数中的this指向了第一步创建的对象
3. 将第一步创建的对象的**proto**指向了原函数的**prototype**
4. 检查原函数是否主动返回对象，如果没有，返回以上3步处理之后的新对象


### 类
- 类：是一种抽象出来的类别
	- 实例：是根据类，具象出的实际的对象
	- 实例 === 对象
## 原型
### prototype
- 专属于函数（箭头函数除外）的一个属性
- 原型对象，显示原型，用来给将来函数被new出来的实例做父级使用
- 将方法写在prototype内，以供将来所有new出来的实例使用


### `__proto__`
- 所有数据类型都具有这个属性
- 原型对象，隐式原型，用来指向构造函数当前实例的构造函数的（父级的）prototype
- 该属性在使用过程中可以省略，可以直接找到指向构造函数的prototype身上的属性或方法
- 原型对象，任何一个数据，都具有这个属性。表示自身来自于哪个父类

### constructor
- 表示当前所在的对象，所属的函数
- 专属于prototype，表示当前prototype所属的构造函数
### 对象的属性或方法的读写规则
- (默认情况下)
- 读：使用。先在自身查找，有，就使用，同时停止查找，没有，顺着proto向上级查找，没有继续顺着proto查找，直到顶层（Object的prototype），找不到就抛出undefined
- 写：设置或赋值。先在自身查找，有，写，同时停止查找，没有，直接设置

## 面向对象的常用语法之一
- 将属性写在构造函数内
- 将方法写在构造函数的原型内（默认的constructor会被覆盖，要设置）
- 原型身上的方法的this和构造函数内的this都指向将来的实例
    ```js
        function CreatePeople(n,a,s){
            this.name = n;
            this.age = a;
            this.sex = s;
        }
        CreatePeople.prototype.show = function(){
            console.log(this.name)
        }
        var p1 = new CreatePeople("张三",18,1);
        p1.show();
    ```

## class
**ES6新增**
- js中class的介绍
    - 面向对象编程，有类的概念，但是js中没有类，通过函数模拟类的思想
    - 哪怕ES6中提供了class关键字，其本质也只是老版本中函数实现类的思想的有一层封装，并不是真正的类
- class的语法结构
	```js
		class Fun{
            constructor(n){     // 等同于老语法中的构造函数
                this.name = n;
            }
            // 等同于老语法中的原型
            init(){
                console.log(this.name);
            }
        }
        var f2 = new Fun("root");
        f2.init();
        console.log(f2.name);
        console.log(f2);
	```
- js内置工厂模式的语法
	```js
		function Fn(n){
        	this.name = n;
        }
        Fn.prototype.init = function(){
        	console.log(this.name);
        }
        var f = new Fn("admin")
        f.init();
        console.log(f.name);
        console.log(f);
	```

# 闭包
## 概念
- 利用作用域的嵌套，将函数内部的变量，进化成**自由/私有**变量的**环境**，叫闭包
- 可以在全局作用域内，操作原本的局部变量

## 特点
- 比较消耗性能：原本会随着局部作用域被释放的变量现在又被保存了起来
- 低版本浏览器会造成内存泄漏
- 可以减少在全局变量的命名污染
- 可以在外部操作内部的变量，方便/不安全（需要的值可能会被修改）
- 可以将原本要删除的值，临时保存起来，方便再次使用

## 原理
- 表现：作用域套作用域
- 本质：
	- 函数定义的区域：函数定义的作用域
	- 函数执行的区域：函数执行的作用域
	- 关系：
		- 函数在执行时自身可以拿到定义作用域的所有变量
- 垃圾回收机制：
	- 计算机的垃圾回收机制（硬盘）：
		- 要删除的数据，不立即删除，暂存在某个临时区域，如果需要使用，可以回收再利用，真正不用了在清空
	- 内存的垃圾回收机制：
		- 要删除的数据，直接删除
- **利用作用域的嵌套，触发了计算机的垃圾回收机制，将原本要删除的变量，临时保存到作用域中**

## 应用
- 循环内绑定事件中要使用循环内的变量
- 给不能串参的函数传参：事件处理函数
- 循环中的事件
- 事件处理函数的传参
- 计时器的回调函数传参

# 继承
## 概念
- 让一个原本没有某个方法或功能的对象或类，具有另一个对象或类的功能或方法

## 方式
- 子承父业：原型的继承
- 授权使用：改变this的指向继承

## 原型/this相关
- 原型
	- 显示原型：函数的prototype
		- 给将来的实例做父级使用
	- 隐式原型：实例的`__proto__`
		- 用来指向自身的父级
- this
	- 当前函数的执行对象
	- 强行修改
		- 函数的方法：call，apply，bind
	- new之后的实例

## 继承的方式
- 改变this的指向继承
	- 方便
	- 多继承
	- 只能继承构造函数内部的内容
	- 不能继承原型上的内容
- 原型继承
	- 拷贝继承
		- 注意深浅拷贝
		- 多继承
		- 只能继承原型
		- 不能继承构造函数
	- 改变原型指向（原型链继承）
		- 能继承原型
		- 能继承构造函数
		- 不方便传参数
		```
		原型指针：
        // 默认情况
            // p实例.__proto__ -> Parent构造函数.prototype
        // 原型链继承之后
            // c实例.__proto__ -> Child构造函数.prototype -> p实例.__proto__ -> Parent构造函数.prototype
		```
	- 借助方法(Object.create)
		- ES6提供的Object.create
		- 根据传入的参数对象，创建新对象，新对象的原型指向参数对象
- 组合（混合）继承
	- 二合一
		- 改变this指向 + 原型（常用继承方式之一）
			- 改变this指向+原型继承
			- 既可以继承构造函数的属性和方法
			- 也可以继承原型身上的属性和方法
			- 方便传参
	- 官方提供（extends  super）Es6的class语法
		- 继承中的角色
			- 父类
			- 子类
			- 父类是子类的超类（super）
		- 实质：改变this指向 + 原型链继承
		```js
			class Parent{
                constructor(n){
                	this.name = n;
                }
                show(){
                	console.log(1)
                	console.log(this.name)
                }
            }
            class Child extends Parent{
                constructor(n){
                    super(n)
                }
            }
    
           var p = new Parent("校长");
           p.show();
           var c = new Child("主任");
           c.show();
    ```
    
## 继承的应用场景
- 面向对象功能的复用性
- 提升程序的性能，降低内存的消耗

# 原型
## 对象中的`__prot__`
- js中万物皆对象，每个数据都会有一个`__prot__`的属性，这个属性叫**隐式原型**，一个对象（obj）的隐式原型（`__prot__`）指向构造该对象（obj）的构造函数（Object()）的原型属性（object.prototype），这样做的原因是为了能够保证实例（obj）能够访问到在构造函数（object）的原型属性（object.prototype）中定义的属性和方法

## 函数中的protyoe
- 函数是一个特殊的对象，除了和其他对象一样有上述的`__prot__`属性外，还有自己特有的属性--原型（prototype）这个属性被描述成指针，它指向一个对象类型的数据这个对象的用途就是包含所有将来使用该函数构造出来的可被共享的属性和方法（我们把这个对象叫做**原型对象**）
- 原型对象中也有一个属性，叫做constructor，这个属性包含了一个指针，指回原函数，（类似于arguments.callee。但是arguments只能在函数内部获得，而函数原型对象内的constructor属性，可以在任何能访问到这个函数的位置使用）

## 关系
- 构造函数，原型，实例之间的关系
	1. 构造函数Fn身上有属性prototype为原型对象，原型对象内有constructor属性，指向当前prototype所在的构造函数Fn
	2. 在new执行构造函数Fn时，创造了一个实例对象f，实例对象f的`__proto__`指向构造函数Fn的原型prototype
	3. 因为实例对象f的`__proto__`指向构造函数Fn的原型prototype，所以实例对象f可以间接访问到Fn原型prototype的方法
	
## 检查实例与构造函数的关系
- 查看实例对象f是否有指针指向构造函数Fn的原型
	- isPrototypeOf()
		- 用于检测两个对象之间似乎否存在这种关系
		- Fn.prototype.isPrototypeOf(f) //查看 Fn 的 prototype 对象，是否是 f 原型
	- instanceof
		- console.log(f instanceof Fn)//查看f对象是否是构造函数Fn的实例
		- console.log(f instanceof Object)
- 两种方法都是：如果是返回true，如果不是返回false
- 【注】：instanceof运算符右侧是构造函数，并且js中所有原型都来自Object构造函数

## js解析器访问属性顺序
- 当访问实例f的属性或方法时，会先在当前实例对象f中查找，去过没有找到，则沿着`__peoto__`继续向上寻找，如果找到最顶头的Object还是找不到，则会抛出undefined。如果在实例中找到，或某层原型中找到，就会读取当前值并执行，同时停止向上寻找
- 由此可见，解析器的解析顺序遵循就近原则，如故在最近的位置发现属性的存在，便不会向上寻找

# 设计模式
## 概念
- 是一套经过反复使用，多人知晓，经过分类的，代码设计经验的总结
- 为什么要使用设计模式？
	- 为了代码的可重用性，让代码更容易被他人理解，保证代码的可靠性，设计模式使代码的编写真正的工程化

## 常用设计模式
- 构造器模式、模块化模式、暴露模块化模式、单例模式、工厂模式、中介则模式、原型模式、命令模式、外观模式、Mixin模式、装饰模式、哼元（Flyweight）模式、组合模式、适配器模式、外观模式、观察者模式、迭代器模式、惰性初始模式、代理模式、建造则模式、MV*模式（MVC、MVP、MVVM）
- 设计模式实在面向对象编程中使用
	- 面向对象：内功
	- 设计模式：招式

## 工厂模式
- 批量创建对象
- 特点：原料对象，属性或方法的加工，返回
- 语法
	- 构造函数创建对象
	```js
	    function Fn(){
        	this.name = "admin"
        }
        var f = new Fn();
	```
	- 封装成函数
	```js
	    function fn(){
        	var obj = {};
        	obj.name = "admin";
        	return obj;
    	}
    	var f = fn();
	```

## 单例模式
- 只能创建单个对象，和工厂模式相对
- 特点：每次创建的都是同一个对象
- 单个对象
	
	- `var obj = {}`
- 构造函数实现单例模式
	```js
	function Fn(){
		if(!Fn.obj){//判断构造函数内是否有obj
			Fn.obj = {}//没有就创建一个
		}
		Fn.obj .name="李四"//给创建的对象设置一个属性name
        return Fn.obj //返回自己的对象（每次返回的都是自己的对象）
        }
	```

## 组合模式
- 将类或对象按照一定的关系组合起来，可以实现批量执行的功能
- 一般应用在**动态**html结构上
- 组合成树状结构，对象节点
	- 根对象
	- 枝对象：具有子对象节点
	- 叶对象：不具有子对象节点
- 节省操作、性能消耗大
- 先创建一个组合器
	- 在组合对象

## 适配器模式
- 适配器：将原本不符合接口的数据或信息，包装成符合的数据接口或信息，这个包装就叫适配器
- 手机，平板（非通话）
	- 只有一个测试部门
	- 按照最全的功能测试
        - 手机：打电话，玩游戏，听音乐
            - 平板：玩游戏，听音乐
- 适配器的意义：
	- 多数应用在系统接口使用，也就是别人提供了一个功能，但要求传入一个A类型的参数，我们手里的数据是B类型的，如果想使用，有2个方法
	1. 把自己的源代码修改，让B类型改为A类型（不合适）
	2. 我们把B类型的数据进行包装，让他看起来符合A类型，这个包装函数，就是适配器

## 观察者模式
- 观察者模式也叫发布订阅者模式
- 订阅者（观察方，接收对象）：接收信息
- 发布者（被观察方，主体对象）：发布信息
- js中的监听式事件绑定

## 代理模式
- 代理，委托
- 系统功能A，系统调用，会产生数据的传输
- 给系统功能A做个代理，让系统调用代理
- 代理功能自定义完成，截获，另做他用，另行加工
- 事件委托
- 服务器代理

## 策略模式
- 功能的执行方式
- 策略，战术，计划
- 提前将可能发生的情况多考虑到，并给出对应的解决方案
- 场景：
	- 轮播图的中的左右按钮的区分
	- 左右移动方向的确定
	- 小标被点击时的方向

## MVC模式
- M：model	模型，数据
- V：view	视图
- C：ctrl	控制器
- 执行顺序
	1. 用户/系统调用控制器发起指令
	2. 控制器接受指令,根据指令调用对应的模型
	3. 模型返回数据，控制器保存数据
	4. 控制器根据指令，调用对应的视图
	5. 将保存的数据，发给视图
	6. 视图做数据的渲染

# 交互
## 前后端交互 

### 1. web前端 - 浏览器
- 发送
	- 表单发送
- 接收
	- 浏览器默认接受
### 2. 后端 - 服务器
- 发送
	- echo		  echo的速度快于print ，echo没有返回值
    - print		     print有返回值，且返回值总为1
    - print_r()		将复杂数据转成字符后发送
    - die()		     发送数据后会终止程序执行
- 接收
	- $_GET		  接收get发送的表单
    - $_POST	  接收post发送的表单
    - $_REQUEST     接收get和post发送的表单
### 3. 服务器-
- 提供服务的机器，也是一台计算机，超级计算机，给众多用户提供的服务能力。专门的网络、专用的机器、专人维护、永不宕机。
### 4. 获取服务器
- 买
    - 真实服务器：成本高
    - 虚拟服务器：云服务器，组别人的服务器
- 模拟
	- 电脑模拟虚拟服务器（本地服务器）
		- 工具，单独的工具
		- 工具包
			- phpstudy
				- apache：默认端口是 **80**
				- php语言包
				- 数据库：mysql 默认端口是 **3306**
- 文件，代码，资料
	- 放在服务器的根目录
		- phpstudy的是www文件夹
		- 常见的根目录名字：www、web、webroot、wwwroot
### 5. 如何使用本地服务器
- 安装集成工具
- 启动对应的服务
	- apache：80
	- mysql：3306
- 访问服务器
	- 专用的**服务器**地址
		- 默认情况下：本地服务器的地址
			- localhost：80
			- 127.0.0.1：80
	- 服务器的根目录
		- 只有放在这个目录中，才能被apache找到，作为服务内容发给用户
		- 可以指定，根据不同的软件，目录有所差别
			- phpstudy：安装路径/www
		- 只有在这个文件夹中，才能被服务器访问
			- **localhost就表示这个根目录**无法使用../跳出根目录
		- 如果需要将一个网站火页面用过服务器环境运行，必须将所有内容（站点）都拷贝到服务器的根目录
		- **在服务器环境下不要出现中文路径**
### 6. 后端程序如何编写
- 准备好平台（对应服务器）
- php

## PHP
### 1. php 写在哪
- 后端语言（服务器语言）
- 运行在服务器环境中
	- 将文件放在服务器的根目录中
- 创建一个php文件
	- 后缀名：.php
### 2. 怎么写
- 基础结构
	```php
		<?php
			#php代码
		?>
	```
- 基础语法
	- php的大部分语法和js相同
        - if(true){}
            - if(false){}else{}
            - switch(){}
            - for(){}
            - while(){}
            - do{}while()
            - function fn(){}
	- php的变量
		- `$`
        	- php没有打印语句，只有发送
            - echo $a;
            - print $a;
            - print_r($a); - 将复杂数据转成字符后发送
			- die($a) - 发送数据后会终止程序执行
		- 思想
			- php文件只能被服务器解析，解析之后，将数据发送到前端，前端如果没有主动接收，浏览器默认接收，也就是直接将发送到前端的数据，显示在浏览器
			- 如果发送了html标签，可以直接被浏览器解析
		- 数据类型
			- 字符，整形，浮点型，布尔，NULL
			- 对象，数组，函数，资源型（数据库）
			- 检测数据类型
				- var_dump($a);
		- **语句结束必须加分号，除非最后一行**
		- 字符串
			- $a = "hello";
			- 支持换行写
			- 连接符`.`
		- 注释
			- #
			- //
		- 数组
			- **没有点语法，只有中括号语法**
			- 索引数组
				- $arr = array(1,2,3,4,5);
				- 长度的方法：count($arr)
				- 转json的方法：json_encode($arr)
				- 数组的遍历：foreach($arr as $a=>$b)
				- 数组排序：
					- sort() 升序
					- rsort() 降序
			- 关联数组
				- $arr = array("name"=>"admin","age"=>18,"arr"=>$arr1,"o"=>$arr2);
		- 实例和类
			- class obj{
				var $name = "admin";
				function(){
				echo $this->name;
				}
			}
			- var 声明属性的关键字
			- ->等同于js的.
		- 作用域
			- 不允许跨作用域拿数据，必须借助global关键字
			```php
			function fn(){
				global $a;
				$a = 10;
				echo $a;
			}
			fn()
			echo $a;
			```
## 数据库
### 1. 数据库的操作
- 建立链接
- 操作数据库：创建数据库
- 操作数据表：创建数据表
	- 创建字段，设置数据类型
- 操作数据：插入数据，删除数据，更新数据，查询数据
### 2. 使用编程语言操作数据库 - **php**
- 建立连接（2种方法）
	- mysqli_connect("localhost:3306","root","root","sh2009");
	- 参数（数据库的地址和端口，用户名，密码，要选择的数据库）
	- new mysqli("localhost:3306","root","root","sh2009")；
- 选择数据库
- 数据的操作
	- 配合mysql命令，实现数据的增删改查（字符形式）
	- 增："INSERT stu (userName,age) VALUES('root',19)"
	- 删："DELETE FROM stu WHERE Id>20"
	- 改："UPDATE stu SET age=age+1"
	- 查："SELECT * FROM stu";
	- 查询：mysqli_query(选中的数据库，插入的数据)
- 查看数据方法
	- 索引数组+关联数组查看数据：$res->fetch_array()
        - 索引数组查看数据：$res->fetch_row();
            - 关联数组查看数据：$res->fetch_assoc();        √
            - 对象方式查看数据：$res->fetch_object();
            - 以上四种方式每次执行返回一条记录的数据，可配合循环多次执行，查询所有数据

## js的执行机制
### 1. 同步和异步
- 生活中的同步异步：
	- 生活中的同步：同时执行，一起执行（两人三足）
	- 生活中的异步：不同时执行，一个接一个（接力跑）
- 程序中的同步异步**与生活中完全相反**
	- 同步：不一起执行（大部分都是同步执行）
	- 异步：一起执行（计时器，事件，ajax）
### 2. 程序
- 表示一个功能
### 3. 进程
- 一个功能从开始执行到执行结束
### 4. 线程
- 一个功能从开始执行到执行结束的过程中，有几个执行分支，每个分支就是一个线程，线程越多，执行速度越快，但是消耗的性能也高
### 5. js的执行机制：单线程的异步执行程序
- 先执行宏任务，后执行微任务，微任务必然在宏任务完全结束后，才能执行
- 宏任务
- 微任务

## Ajax
### 1. 介绍
- 是前后端交互的重要手段
- a：Asynchronous 异步
- j：javascript
- a：and
- x：服务端的数据（json，xml，html，txt...）
- ajax不是单一的技术，而是一组技术的组合
	- 异步的js：ajax自身的事件，（加载事件）
	- xhr：XMLHttpRequest，载体，用来连接前后端，进行信息传输
	- 其他js：
	- 服务端的数据：json，xml，html，txt...
- ajax的特点：
	- 在不中断浏览器的其他任务的情况下加载新数据（无刷新加载数据）
	- 提升了页面的初始加载速度
	- 无法通过浏览器的前近后退按钮，拿到曾经的数据
	- ajax请求的数据，无法被搜索爬虫检索，破坏了网站的SEO（搜索引擎优化）
- ajax的引用场景
	- 需要前后端交互
	- 有前端
	- 有后端
		- 运行在服务器环境中
		- ajax也需要运行在服务器环境中
### 2. ajax的使用
- 创建载体：`var xhr = new `
- 
	- 有兼容:`var xhr = new ActiveXObject("Microsoft.XMLHTTP")`  IE5
- 连接前后端：`xhr.open("get",url,true)`
	- 参数1：传输方式；参数2：传输地址；参数3：同步或异步（t：同步；f：异步）
- 等待连接：onreadystatechange（事件）
	- xhr.readyState  ajax的执行状态（0，1，2，3，4）
	- xhr.status      http协议的状态（200表示连接成功）
	- xhr.responseText 接受到的数据
- 发送数据：send()
### 3. 封装

    ```js
        function ajax(ops){
            let {url,type="get",data={},success,error}=ops;
            let ajax = new XMLHttpRequest();
            str = "";
            for(let i in data){
                str += `${i}=${data[i]}&`;
            }
            url = type === "get" ? url + "?" + str + "__wxt" + Date.now() : url;
            ajax.open(type,url,true);
            ajax.onload = function(){
                if(ajax.status === 200){
                    success(ajax.responseText);
                }else{
                    error && error(ajax.status);
                }
            }
            if(type === "get"){
                ajax.send();
            }else if(type === "post"){
                ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
                ajax.send(str.slice(0,str.length-1));
            }
        }
    ```

### 4. get请求
- 会触发浏览器的缓存
- 缓存：缓冲储存，临时储存
- 浏览器打开网页时会将一些资源下载到本地，以提升**下次打开同一个地址**时的速度
	- 缺点：有可能无法拿到最新数据
- 如何绕过缓存
	- 走缓存的原因：下次打开同一个地址
	- 保证每次打开的都不是同一个地址就不会走缓存
		- 在url后加时间戳（Date.new()  获取事件戳） 
### 5. post 请求
- post请求不会被浏览器缓存
- post请求的数据不在url后拼接，在xhr对象的send方法中发送
- send之前要修改数据被解析的格式
	- `ajax.setRequestHeader("Content-Type","application/x-www-form-urlencoded");`

### 6. ajax存在的问题
- 跨域
	- 浏览器的安全策略：同源策略
		- 浏览器认为：请求源和请求目标必须出现在同一源下，不在同一源下，浏览器会阻止这次请求，因为浏览器认为不安全
		- 同源策略：同协议，同域名，同端口
	- 当请求的资源与请求目标不在同一协议、域名、端口称作跨域
	- 在请求的目标资源，没有明确允许的情况下，会被浏览器**限制ajax，没有限制html标签的请求**
- 程序员在与浏览器的安全策略左斗争的过程中发明了一种跨域的方式：jsonp
	- 原理：利用script标签可以实现跨域的特性，请求资源
		- 并不是所有标签都能请求，a是跳转，img是图片，link是引入css文件
		- script是引入js，js逻辑，处理编程
- script标签
	- 可以跨域
	- 将引入的资源自动作为js代码执行
- jsonp
	- php会被服务器解析，解析之后，php返回的字符，才会被script标签作为js代码解析
	- 利用前端定义的函数，在后端资源中被返回js的执行语句，又使用script标签加载后端资源，script标签会将后端返回的字符作为js解析，最终在后端执行了前端定义的函数，并通过传参实现跨域数据的传输
	- 的封装	

### 7. 数据的来源 - API
- 数据库
- 接口（API）：后台提供的可以请求的接口
	- 自己写的接口
		- 后台，数据库
		- 处理数据库的数据
		- 返回给前端
	- 别人写好的接口
		- 读接口文档
			- 根据接口要求，使用接口，解析数据
		- 没有主动权
### 8. **跨域的解决方法**
- 前端解决跨域的方法：**isonp**
	
	- 缺点：需要后台配合
- 后台解决跨域的方法：**CORS**
	- 给后端资源设置允许请求
	```
	header('Access-Control-Allow-Origin:*');//允许所有来源访问
	header('Access-Control-Allow-Method:POST,GET');//允许访问的方式
	```
- **服务器请求数据**
	
	- 服务器代理
	- 原理：
		- 客户端a，请求服务端B的数据，跨域
		- 自己搭建一个服务器A，请求服务端B的数据
			- 没有经过浏览器，没有跨域，直接拿到数据
			- 数据保存在服务器A中
		- 客户端a，请求自己的服务器A，没有跨域

## Promise - 承诺
- ES6新增的本地对象，需要new之后才能使用
### 意义 
- 异步套异步的程序称之为回调地狱
	- 回调地狱可以解决异步中存在的异步的问题
		- 有递归的逻辑，极其的消耗性能
		- 不方便维护
		- 伤害了代码的可读性
	- promise是ES6中提出的解决回调地狱的方案
### 语法
	```js
		var p = new promise((resolve,reject)=>{
			//promose已完成，由then的第一个参数传递
			//reject未完成，由catch的参数或then的第二个参数传递
		})
		p.then(()=>{})//处理成功
		p.catch(()=>[])//处理失败
	```
### promise的方法
- then和catch是promise实例的方法
	- then和catch的回调函数，返回值可以是一个新的promise对象
	- 如果返回值是新的promise对象，可以在当前then或catch后继续连缀处理新的promise对象的状态
- all和race是promise构造函数的批处理方法，执行结果也是promise对象，可以被then或catch处理成功或失败的状态
	- all：全部请求结束，参数是数组
	- race：只要有一个请求结束，参数是数组
- promise的作用
	```js
		var p = new promise(()=>{//开启承诺
			var p1 = ajax(url)//正在进行（异步程序）
			var p2 = ajax(url)//正在进行（异步程序）
			
			promise.all([p1,p2]).then(()=>{})//批处理成功
			promise.all([p1,p2]).catch(()=>{})//批处理失败
			
		})
		p.then(()=>{})//处理成功
		p.catch(()=>{})//处理失败
	```
	
## 本地存储
### 概念
- 本地：非服务器
- 存储：存数据
- 并不是所有数据都需要存在服务器，如果非要存在服务器，会增加服务器的负担，也可以将数据存在客户端（本地存储技术）
- 本地存储技术
	- cookie
	- localstorage
	- sessionstorage

### cookie
1. cookie产生的原因
	- 通信协议
		- Ip：用来识别接入互联网的每台机器的唯一标识
		- TCP/UDP：传输底层的数据包
			- TCP：可靠的传输协议，三次握手协议，面向连接的协议
			- UDP：不可靠的协议，面向数据包的协议
		- FTP：用来传输文件，客户端向服务器上传/下载文件
		- HTTP：传输网页的协议，超文本传输协议，无状态协议
			- 无状态：没有记忆
			- 会话跟踪技术：用来记录每次会话话期间产生的所有需要记录的信息
				- cookie
2. cookie
	- 会话跟踪技术：用来记录每次会话期间所产生的所有需要记录的信息
	- 数据记录到哪
		- 客户端的浏览器的缓存中
		- 会随着http协议发往服务器
3. cookie数据的特点
	- 只可以文本（字符）
	- 大小限制：4k~
	- 数量限制：50条~
	- 不允许跨域，不允许跨路径
	- 时间限制：默认是会话级，可以指定时间
	- 建议：真实项目中，不要在cookie中直接存储铭感信息。安全原则
4. cookie的使用
	- document.cookie
		- 字符型数据
		- 一次只能存一条
		- 数据中包含名字和值，和配置信息
		- `document.cookie = "key=val;path=路径;expires="+时间对象+";domian=服务器（127.0.0.1）"`
	- **注**：本地储存可以不依赖服务器，但是因为cookie会默认发往服务器，所以cookie最好在服务器环境下使用
	
5. cookie的封装
	- 设置
	```js
        function setCookie(key,val,ops={}){
            var expires = "";
            if(ops.expires){
                var d = new Date();
                d.setDate(d.getDate()+ops.expires)
                expires = ";expires=`"+d;
            }
            var path = ops.path ? `;path=${ops.path}` : "";
            document.cookie = `${key}=${val}${path}${expires}`;
        }
	```
	- 获取
	```js
        function getCookie(key){
            var data = document.cookie.split("; ");
            for(var i = 0;i<data.length;i++){
                if(data[i].split("=")[0]===key){
                    return data[i].split("=")[1];
                }
            }
            return "";
        }
	```
	- 删除
	```js
        function removeCookie(key,ops={}){
            ops.expires = -1;
            setCookie(key,null,ops);
        }
	```
### storage
1. 特点
	- 只可以文本（字符）
	- 大小限制：2M~
	- 数量限制：50+~
	- 时间限制：
		- localStorage：永久级
		- sessionStorage：会话级
2. localStorage
  - 永久级，没有时间，不能设置时间
  - HTMl5新增的API
  	- localStorage是window的子对象
  	- 自身可以作为对象使用，键值对
  	- window.localStorage
  	- window.localStorage.user = "admin"
  	- window.localStorage["pass"] = "123"
  - localstorage自带的方法
  	- localStorage.setItem("a","10");	添加
  	- localStorage.getItem("a");		获取
  	- locolStorage.removeItem("a");		删除
  	- localstorage.clear();				清除所有
3. sessionStorage
  - 会话级，没有时间，不能设置时间
  	- HTMl5新增的API
  	- sessionStorage是window的子对象
  	- 自身可以作为对象使用，键值对
  	- window.sessionStorage
  	- window.sessionStorage.user = "admin"
  	- window.sessionStorage["pass"] = "123"
  - sessionstorage自带的方法
  	- sessionStorage.setItem("a","10");	添加
  	- sessionStorage.getItem("a");		    获取
  	- sessionStorage.removeItem("a");	 删除
  	- sessionStorage.clear();				      清除所有
4. storage事件
  - 浏览器（window）的事件
  - 检测storage的变化
  - 不会触发当前页面的事件，触发的是别的页面的事件
  - 有兼容，兼容运行环境，只能在服务器中运行






# JQuery
## 介绍
- [官网](https://jquery.com/)
- 特点
	- jQuery是一个快速，小型且功能丰富的JavaScript库。通过易于使用的API（可在多种浏览器中使用），它使HTML文档的遍历和操作，事件处理，动画和Ajax等事情变得更加简单。兼具多功能性和可扩展性，jQuery改变了数百万人编写JavaScript的方式
	- 写的更少，做的更多

## 基本选择器
- 原生DOM对象的方法不能与jq对象的方法混用
	- jq选择器返回的都是数组，但是可以在jq的方法中直接使用
- 转换
	- 原生转jq：$("ele")
		- 将原生的DOM的对象传给jq，返回值就是转换结果
	- jq转原生
		- 通过索引解析数组：$("box")[0]
		- 通过专属的方法get解析数组：$("box").get(0)
### css相关
- $()/JQuery()
	- 传字符参数
- $("#box")：id选择器（失明特征，只选择一个）
- $(".box")：class选择器
- $("div")：标签选择器
- $(".box[a=abc]")：属性选择器
- frist：第一个
- last：最后一个
- eq()：第几个（从0开始）
- even：奇数
- odd：偶数
- not()：除了此条件
- contains(txt)：内容包含txt的
- empty：内容为空
- hidden：隐藏的元素
- visible：显示的元素
- addClass：添加属性
- removeClass：删除属性

### jq特色
- find：后代  相当于css的空格
- children：子  相当于css的>
- next：下一个同级元素 	相当于css的+
- nextAll：下面所有同级	相当于css的~
- nextAllUnnitl：下面所有同级，参数为区间结束，不包括参数
- prev：上一个同级元素
- prevAll：上面所有
- prevAllUnitl()：上面所有区间，参数为区间结束，不包括参数
- has()：符合条件的后代元素
- parent：单个父级元素
- parents：所有父级元素
- parentUnitl()：父级区间，参数为区间结束，不包括参数
- siblings：除自己外所有的兄弟元素

## jq的动画
- 内置动画
	- 左上角动画（参数1：动画时间，参数2：动画执行完毕的事件）
        - hide：隐藏
            - show：显示
            - toggle：隐藏/显示
	- 上拉下拉（参数1：动画时间，参数2：动画执行完毕的事件）
		- slideUp：上拉隐藏
		- slideDown：下拉显示
		- slideToggle：上拉/下拉
	- 淡出淡入（参数1：动画时间，参数2：动画执行完毕的事件）
		- fadeOut：淡出隐藏
		- fadeIn：淡入显示
		- fadeToggle：淡出淡入
	- 透明度（参数1：动画时间，参数2：透明度，参数3：函数）

- 自定义动画
	- animate()
		- 参数1：对象（需要设置的css属性，支持字符，数值，+=：原来的参数加上设置的参数）
		- 参数2：毫秒数，可选
		- 参数3：动画执行结束后，可选

- 动画的执行顺序
	- jq中在一个动画结束后开启下一个动画的实现方法
		- 回调函数
		- 单独开启
		- 连缀执行
	- **jq中动画与动画时同步执行**
	- **jq中动画与其他方法是异步执行**
	- **queue**
		- 参数：函数
		- 将此函数作为前一方法的回调函数

- 动画的停止和延迟
	- 停止：stop()
		- 参数1：布尔值（等待中动画）
			- false：不清除列队（默认）
			- true：清除列队
		- 参数2：布尔值（当前动画）
			- false：停止当前（默认值）
			- true：直接到目标，神略动画过程
	- 延迟：delay()
		- 参数：要延迟的毫秒数
	- **动画是同步执行，同步执行事件同时开启多个，会产生队列**
	- 动画的队列
		- 当前动画正在执行
		- 后面还有等待的动画

## jq的DOM操作
### 属性操作
#### 属性
- html：标签的内容，不包括标签   相当于innerHTML
	- 无参数：获取内容
	- 参数：字符`<div>`，加结束标签的话可以直接添加内容
	- 可以解析标签
- text：标签内的文本信息    相当于innerTEXT
	- 无参数：标签内的文本内容
	- 参数：字符，要替换成的文本
	- 不能解析标签
- val：表单的内容     相当于value
	- 无参数：获取值
	- 有参数：将参数内容赋值到表单的value
- removeClass：删除元素的class
	- 只删除参数中的class，不全部删除
- addClass：添加class
	- 在原有的基础上继续增加，不覆盖
- toggleClass：自动添加或删除
	- 如果有参数的class属性就删除，没有就设置
- css：设置样式
	- 参数：
		- 一个字符：获取样式
		- 一个数组：获取样式
		- 两个字符：设置样式
		- 一个对象：设置样式
- attr：设置自定义属性
	- 参数1：属性名
	- 参数2：属性值
	- 只有一个参数时，获取
	- 支持一个对象，同时设置多个自定义参数
- removeAttr：删除自定义属性
	- 参数：要删除的属性名
- each：遍历对象
	- $.each(obj,function(index,value){
			console.log(index, value)
		})
#### 位置
- width：宽度
	- 只包含width
- innerWidth：包含内边距的宽度
	- width+padding
- outerWidth：包含宽度，内边距，边框
	- border+width+padding
- offset：元素相对于浏览器的宽度
	- 定位+margin
	- 返回一个对象，包含top，left
- position：相对于父元素偏移的距离
	- 只有定位
	- 返回一个对象，包含top，left
- scrollTop：滚动条的值
	- 无参数：获取
	- 有参数：设置
- scrollWidth：滚动条的值
	- 无参数：获取
	- 有参数：设置
#### 元素的增删改查
- 创建节点
	- `$("<p>123<p>")`
	- 直接写
- append：插入元素内最后
	- $(".box").append(p)
	- 把p插入到box
- appendTo:插入元素内最后
	- p.appendTo($(".box"))
	- 把p插入到box
- prepend：插入元素内部前
- prependTo：插入元素内部前
- after:插入指定元素后
- before：插入指定元素前
- **clone**：复制元素
	- 参数为true时复制元素的事件
	- `$('body').append($('div').clone(true))`
	- 复制一个节点添加到 HTML 
- remove：删除元素节点
- empty：删除匹配的元素集合中所有的子节点
- replaceWith：替换元素

## jq的事件
- jq的事件都是DOM2级事件绑定
### 常规绑定
- 选择器.click(function(){})
- 原生的方法没有on
- jq特有的ready事件
	- 只加载结构，不加载资源
	- `$(function(){})`
	- `$().ready(function(){})`
### on绑定
- `$().on("click.a","li",function(){})`
	- 参数1：事件，可以给后面的执行函数起名字，加载点（.）后
	- 参数2：事件委托时加，要委托的元素，（可选）
	- 参数3：事件处理函数
- 用off删除on绑定的事件
	- $().off("click.a")
- on绑定事件委托
	- `$().on("click.a","li",function(){})`
	- this指向当前事件目标
### hover绑定
- 鼠标进入和离开
- `$().hover(function(){},function(){})`
	- 参数1：鼠标进入事件
	- 参数2：鼠标离开事件
	- 封装的是mouseenter/mouseleave（没有事件冒泡）
### one绑定
- 绑定一个一次性事件

### bind绑定
- jq3删除，不可以事件委托
- `$().bind("click.a",function(){})`
	- 参数1：事件，可以给后面的执行函数起名字，加载点（.）后
	- 参数2：事件处理函数
- 用unbind删除bind绑定的事件
	- $().unbind("click.a")

### 模拟事件执行
- **trigger**:模拟事件执行
- **triggerHandler**模拟事件执行，没有事件冒泡
- 轮播图自动下一张
	```js
	$(".box").click(function(){
        console.log("切换下一张轮播图");
    })
     setInterval(() => {
        会触发事件冒泡
        $(".box").trigger("click");
    }, 2000);
    //不会触发事件冒泡
    $(".box").triggerHandler("click");
	```
	
## jq的ajajx
- ajax的返回值是一个伪promise的对象
- 可以使用promise类似的使用方法
- jq的ajax请求数据成功后会有3个返回值
	- 成功res，stat，xhr
		- 数据，状态，xhr对象
	- 失败xhr，stat，res
		- xhr对象，状态，数据


### 上层方式
- $.getJSON():获取json
- $.getScript():获取script，实现跨域
- $().load():获取html数据

### 中层方式
- $.get()：只能get
- $.post()：只能post
	```js
	var url = "http://localhost/ws2009/jq-ajax/data/data.php";

    var p = $.get(url,{
        user:"admin"
    },(res,b,c)=>{
    });

    // console.log(p);
    p.then((res,b,c)=>{
        console.log(res, b, c)
    },(code,b,c)=>{
        console.log(code, b, c)
    })
	```

### 底层方式
- $.ajax():
	- 参数：对象
		- async:true（是否异步，默认true，异步）
		- url:"data.php"（请求数据的地址）
		- type:"get/post"（传输类型）
		- data:{user:"admin"}（发送的消息）
		- success:(res,stat,xhr)=>{}（请求成功）
		- error:(xhr,stat,res)=>{}（请求失败）
		- timeout:100（超时）
		- beforeSend:()=>{}（请求之前要干什么）
		- dataTye:"jsonp"（数据转换类型，一般不用，jsonp时写）
		- jsonp:"callback"（后端返回数据的函数名，确定时写）
		- global:true（ajax的全局状态（生命周期）默认true）
- ajax的公共配置
	- $.ajaxSetup()
	- 当ajax请求数据时有重复的代码时可用
	- 例：请求同一个地址...
		```js
		$.ajaxSetup({
        url:"http://localhost/ws2009/jq-ajax/data/data.php",
        success:res=>{
            alert(res)
        }
    	})
		```

- ajax的全局状态的全局函数类型
	- ajaxStart：xhr实例创建前
	- ajaxSend：xhr创建成功，发送给服务器之前
	- ajaxSuccess：请求成功，且包含成功的状态码
	- ajaxError：请求失败，且包含失败的状态码
	- ajaxComplete：请求完毕且数据已返回
	- ajaxStop：请求结束
	```js
	$(document).ajaxStop(function(){
        alert("ajaxStop")
    })
	```
|全局函数类型|何时被触发|参数|
|-|-|-|
|ajaxStart|在jQuery AJAX函数或命令发起时，但在XHR实例被创建之前|类型被设置为ajaxStart的全局回调信息对象|
|ajaxSend|在XHR实例被创建之后，但在XHR实例被发送给服务器之前|类型被设置为ajaxSend的全局回调信息对象；XHR实例；$.ajax()函数使用的属性|
|ajaxSuccess|在请求已从服务器返回之后，并且响应包含成功状态码|类型被设置为ajaxSuccess的全局回调信息对象；XHR实例；$.ajax()函数使用的属性|
|ajaxError|在请求已从服务器返回之后，并且响应包含失败状态码|类型被设置为ajaxError的全局回调信息对象；XHR实例；$.ajax()函数使用的属性；被XHR实例返回的异常对象(如果有的话)|
|ajaxComplete|在请求已从服务器返回之后，并且在任何已声名的ajaxSuccess或ajaxError回调函数已被调用之后|类型被设置为ajaxComplete的全局回调信息对象；XHR实例；$.ajax()函数使用的属性|
|ajaxStop|在所有其他AJAX处理完成以及任何其他适用的全局回调函数已被调用之后|类型被设置为ajaxStop的全局回调信息对象|



## 表单序列化
- $(".form").serialize()
	- 将表单转换成url?后的格式
	- 必须在form标签内的input，必须有name
- $.param
	- 将对象转换成url?后的格式

## jq的插件
### 插件
- 是一种遵循一定规范的应用接口编写出来的程序
- 表示某个功能的封装

### 现有插件的使用
- 使用方式：jq的插件
	1. 先有jq（先引入jq）
	2. 再有插件（引入插件）
	3. 皮肤包或语言包
	4. 使用插件
- 表单验证插件：validate
- cookie插件：cookie
- 分页插件：pageAction

### 开发自己的插件
- 如何开发jq的插件
	1. 向jq绑定自定义方法或属性
		- $.fn:jq的DOMDOM对象所在的公共区域对象
		- extend
			- $.extend		绑定为jq的全局方法（工具方法）
			- $.fn.extend	绑定为jq的局部方法（DOM方法）
		- 对象操作
			- $.xxx = function(){}		（工具方法）
			- $.fn.xxx = function(){}	（DOM方法）
	2. 独立的js文件
		- 起名：框架名.插件名.版本号.js
		- JQuery.Banner.1.0.js
	3. 开匿名函数，前后加分号
	4. 开严格模式
	5. 美元符$的私有化
		- `(function($){})(JQuery)`
		- 将JQuery作为参数传入匿名函数，$接受
		- 防止其他js重置$
	6. 开始向jq绑定自定义方法或属性
	7. 开发功能↓
- 开发插件
	- banner插件
		- 参数处理
		- 报错处理
		- 选择器处理
		- 业务逻辑处理

# nodejs
## node的介绍
1. 后台语言，类似于php
	- php使用方法：安装apache环境，php的语言支持，php代码文件，操作系统
	- node使用方法：安装node环境，node的语言支持，node代码文件，操作系统
2. node的历史
	- V8引擎：c++搭建（谷歌开源）
	- nodejs（服务端的js）== javascript（客户端的js）
		- 只是运行环境不同，语法完全一致
3. node的易用性
	- node的服务器是php的86倍
	- node的学习成本低，js的语法
	- node的学习资源相对不多
	- 中小型企业项目后端node不多，大型公司或新项目可以采取node

## node的运行方式
1. **没有浏览器**
	- 没有BOM（window），没有DOM（document）
2. 运行在node环境中
	- 将node环境安装在计算机的操作系统内
	- 通过操作系统的命令提示框，通过命令调用node的运行环境，执行node代码，运行node文件
		- win：开始菜单->附件->命令提示符
		- mac：终端
		- linux：终端
	- 第三方软件，封装的命令提示框的入口
		- vsCode：终端
		- HB：终端
		- git：Git bash（linux的终端）
3. 执行文件（运行功能）
	- 首先在命令窗口找到要执行的node文件
		- 系统命令窗口的路径切换（系统命令）
			- 盘符切换：`盘符:`
			- 打开文件夹：`cd 文件夹名`
			- 查看当前文件夹中所肉文件：`dir`
			- 清屏：`cls`
	- 通过node命令执行文件
		- `node 文件名`
4. 命令执行（用来测试代码）
	- 打开命令窗口
	- 进入node解析器
		- `node `（node空格）
	- 写代码，回车运行

## node的语法
1. 基础语法
	- 全面支持ECMAScript6（除了ES6的模块化）
	- **没有BOM(window)，没有DOM(document)**
	- 事件
		- 不是人机交互行为事件
		- 服务端的事件：数据、加载、请求...
2. 特点语法
	- 模块↓

## node的模块化
- 模块化的使用
	- 引入：
		- require("模块所在的文件名")
	- 暴露：
		- `module.exports 要暴露的入口`
		- `exports 要暴露的入口`
### 内置模块
- 直接引入，就可以使用

### 第三方模块
- 先下载，再引入，再使用

### 自定义模块
- 先写，再暴露模块，再引入，再使用
	- 暴露关键字(属性)：exports
	```js
	//moduleA.js
	exports.rand = function(n){
    	return (Math.random()+"").substr(2,n)
	}
	```
	- 引入关键字(方法)：require()
	```js
	//mian.js
	var {rand} = require("./moduleA.js")
	for(let i =0;i<10;i++){
		console.log(rand(4))
	}
	```
	
	
## 内置模块
- node官方封装好的功能模块，直接引入，即可使用
- `const 模块入口 = require("模块名")`

### http模块
- 服务器模块，开启web服务器
	- 引入：`const http = require("http")`
	- 开启：`http.createServer((req,res)=>{}).listen("3000","localhost",()=>{})`
	- 使用：
		- 开启服务器：createServer((req,res)=>{})
			- 参数：函数，该函数可接受两个参数
				- 参数1：req，请求，前端到后台的信息
				- 参数2：res，响应，后台到前端的信息
			- 返回值是一个一个对象
		- 监听服务器：listen("3000","localhost",()=>{})
			- 开启服务器的返回值的方法（可以连缀）
			- 参数1：端口号
			- 参数2：地址（可选，默认localhost）
			- 参数3：函数，服务器开启成功执行的代码（可选）
		- 方法：
			- 前端请求的地址：req.url
			- 给前端发送的数据：res.write()
			- 结束当前请求：res.end()  必须写在最后
### fs模块
- 文件模块，提供了文件的操作
	- 引入：`const fs = require("fs")`
	- 使用:
		- 读取文件
			- fs.readFile("文件路径","utf-8",(err,data)=>{})**异步**
				- 参数1：要读取的文件路径
				- 参数2：字符编码（可选，默认buffer流）
				- 参数3：函数，该函数可以接受两个参数
					- 参数1：err，请求失败时的错误信息
					- 参数2：data，请求到的数据
			- fs.readFlieSycn("文件路径","utf-8")**同步**
				- 参数1：要读取的文件路径
				- 参数2：字符编码（可选，默认buffer流）
				- 返回值为请求到的数据
		- 写入文件
			- fs.writeFlie("文件路径",str,(err)=>{})**异步**
				- 参数1：要写入的文件路径的地址
				- 参数2：要写入的文件的内容
				- 参数3：函数，该函数接收一个参数
					- 参数：err，写入失败的错误信息
			- fs.writeFlieSycn("文件路径",str)**同步**
				- 参数1：要写入的文件路径的地址
				- 参数2：要写入的文件的内容
				- 返回值为undefined 
				
### url模块
- url模块，解析url，将url字符解析成对象
	- 引入：`const url = require("url")`
	- 使用：
		- `const urlObj = url.parse(req.url,ture)`
			- 参数1：要解析的url
			- 参数2：布尔值，是否将解析后的query转成对象
			- 返回值时一个解析后的对象
	- 返回值的属性
|属性|含义|例子|
|-|-|-|
|protocol|协议| ’http‘                                                       |
|slashes|双斜杠|true|
|auth|作者|null|
|host|服务器+端口|'localhost:8002'|
|port|端口| '8002'                                                       |
|hostname|服务器|'localhost'|
|hash|锚点（哈希）|'#title'|
|search|数据|'?username=sdfsdf&content=234234'|
|query|除了?的数据|'username=sdfsdf&content=234234'|
|pathname|文件路径|/aaa'|
|path|地址+信息|'/aaa?username=sdfsdf&content=234234'|
|href|完整地址|'http://localhost:8002/aaa?username=sdfsdf&content=234234#title'|


### querystring模块
- 解析查询数据
	- 引入：`const querystring = require("querystring")`
	- 使用：
		- querystring.parse(数据)
		- 将数据转成对象
			- 参数：要转换的数据


## node的下载工具
1. npm:命令行下载工具 - **包管理器**
	- 查看版本号：npm -v
	- 生成package.json(项目的配置信息)：npm init
	- 下载模块：npm install 模块名（npm i 模块名）
		- 下载到全局：-g
		- 下载到上线环境（运行依赖，项目依赖）：-S
		- 下载到开发环境（开发依赖）：-D
	- 卸载模块：npm uninstall 模块名（npm uni 模块名）
		- 安装到哪个位置就卸载对应位置的模块
2. npm的下载源
	- 官网下载源：https://www.npmjs.com/（服务器在国外）
		- 下载慢，不稳定，可能会被禁掉
	- npm下载源管理工具：nrm
		- 安装：npm i nrm -g
		- 查看版本号：nrm -V
		- 查看现有源列表：nrm ls
		- 切换源：nrm use 源名
		- 测试源速度：nrm test
3. npm下载常见失败解决方式：
	- 超时错误，换网
	- 下载失败：
		- 卸载
		- 清除缓存：npm clean cache -f
		- 重新下载
		- 以上还是失败：
			- 删除：C:\Users\Administrator\AppData\Roaming\npm-cacha（缓存文件）
			- 重新下载
4. 总结
	- npm init
	- npm install 模块

## 路由处理
- 路由处理
	- php服务器的使用：安装集成工具，启动apache，找到根目录，写代码，就可以了
	- node服务器的使用：自己写，自己没写的功能都不存在！！！
### 路由设计模式
- 设计路由1（假设路由）√
    ```
    http://localhost:3000/api?type=login
    http://localhost:3000/api?type=register
    http://localhost:3000/api?type=goods
    http://localhost:3000/api?type=user
    ```

- 设计路由2（假设路由）
    ```
    http://localhost:3000/login
    http://localhost:3000/register
    http://localhost:3000/goods
    http://localhost:3000/user
    ```
#### 利用node跨域
- 利用node服务器搭建代理服务器实现ajax的跨域请求
    ```js
        // 处理前端过来的url，处理成真正要请求资源的url

        // 再利用http或https模块发起请求
        https/http.get(url,(resObj)=>{
            // 解析请求到的对象，解析出数据
            resObj.on("data",(data)=>{
                // 利用当前服务器的响应头对象，将数据发给前端
                res.write(data);
                res.end()
            })
        })
    ```

# gulp
- node的第三方模块
- node的模块开发 - commonJs规范
	- 暴露：module.exports
	- 引入：require()
## 介绍
- 做前端的**自动化工程**，前端自动化工具
- 基于node的前端自动化工具（基于流的前端自动化工具）
- 自动将文件进行压缩、合并、编译、解析等操作
- 类似于将项目打包
- 官网：https://www.gulpjs.com.cn/
- **常用的前端工具**：gulp，webpack，grunt，browserify
- gulp的环境类似于工厂，项目类似于原料和产品
	- 工厂的位置是固定的
	- 原料和产品可以运输

## gulp的使用
1. 下载
	-  安装全局的gulp：`npm i gulp -g`
		- 测试：`gulp -v`可以查看全局的gulp版本号
	- 安装局部的gulp
		- 先创建项目环境（文件夹）
		- 使用命令窗口进入文件夹
		- `npm i gulp -D`安装到开发环境
		- 测试：`gulp -v`可以查看全局的gulp版本号
2. 创建gulp官方指定的文件 ：**gulpfile.js**
3. 在gulpfile.js中引入gulp模块
	
	- `const gulp = require("gulp")`
4. 配置gulpfile.js文件
	- 遵循node的模块化规范
	- 定义功能
	```js
	function sayHello(){
    console.log("hello");
	}
	```
	- 暴露模块
	```js
	//  暴露的入口名
	exports.say = sayHello;
       		//   要暴露的功能
	// 在执行时，通过say执行sayHello
	```
	- 按需执行
		- 在命令窗口输入：`gulp 入口名`

## gulp的常用内置方法
- src()		查找文件（参数：路径、字符串）
- dest()	转存文件（参数：路径、要保存的路径）
- watch()	监听文件的变化，执行功能（参数：路径、是个数组）
- series()	批量执行，同步执行（参数：要批处理的函数名）
- parallel()批量执行，异步执行（参数：要批处理的函数名）
- pipe()	**流对象的方法**
	- 管道方法，用于将流对象传入下一个操作
	- 实现连缀执行
	- 参数：要执行的方法

## 文件路径的写法
- 单个文件：直接文件全称
- 多个文件：使用数组包裹
- 当前文件夹下，所有文件：`"文件夹/*"`
- 当前文件夹下，指定扩展名文件：`"文件夹 /*.扩展名"`
- 当前文件夹下，多层子文件夹嵌套：`"文件夹 /**/*"`
- 当前文件夹下，指定多个扩展名文件：`"文件夹/*.{html,css}"`
- 当前文件夹下，除了莫格文件：`"!src/pass.txt"`(!路径)

## gulp的插件
- 实现最终的项目处理
- 下载
- 引入
- 在gulp的功能中使用插件
- **注意：gulp-uglify压缩不支持ES6语法，需要先将ES6转成ES5之后才能压缩**

## ES6转ES5
- gulp插件是没有ES6转ES5这个功能的
	- babel才是住专门的编译工具
	- gulp只是提供了支持gulp的插件
	- 最终的编译还是由bable完成
- 安装gulp对babel支持
	
	- npm install gulp-babel
- 安装babel对ES6的支持
	
	- npm install @babel/core
- 安装说明，将ES6转成ES5
	
	- npm install @babel/preset-env
- 在gulpFile中使用
	
	- 引入gulp-babel
- 定义ES6转ES5的功能
    ```js
    function stfFn(){
        return src("src/js/*.js")
        .pipe(babel({
            presets: ['@babel/env']
        }))
        .pipe(dest("dist/js"))
    }
    exports.stf = stfFn;
    ```
    
## 服务器插件
- 服务器插件
	- gulp-connect
    ```js
    //转存，拷贝
    function copy(){
        return src(["./src/*"])
                .pipe(dest("dist"))
                .pipe(connect.reload())//文件转存之后，触发connect插件的刷新功能
    }
    exports.copy = copy;
    //监听文件变化，实现自动拷贝
    function autoCopy(){
        return watch("./src/index.html",copy)
    }
    exports.autoCopy = autoCopy;
    //开启服务器,服务器自动刷新
    function server(){
        connect.server({
            port:"3333",        //端口
            root:"./dist",       //根目录
            livereload:true,    //自动刷新，需要给拷贝功能开启每次拷贝都刷新
        })
    }
    xports.server = server;
    //自动刷新需要同时开启服务器与自动拷贝，所以要使用批处理，两个都是异步，所以要使用异步的parallel
    exports.autoServer = parallel(server,autoCopy)
    ```
- 跨域插件
	- http-proxy-middleware
	- 是一个对象，有createProxyMiddleware属性，是一个函数，跨域时使用
    ```js
    //跨域服务器
    function crossServer(){
        connect.server({
            port:"3333",
            root:"./dist",
            livereload:true,
            middleware:function(connect, opt){
                return [
                    //跨域模块是一个对象，它的createProxyMiddleware属性是一个函数
                    proxy.createProxyMiddleware("/api",{//接受两个参数，1：前端请求跨域的标志；2：一个对象（配置信息）
                        target: 'https://wanandroid.com/wxarticle',    //代理的目标地址
                        changeOrigin:true,
                        pathRewrite:{    //路径重写规则
                            '^/api':''
                        }
                    })
                ]
            }
        })
    }
    exports.crossServer = crossServer;
    exports.autoCross = parallel(crossServer,autoCopy)
    ```
- 有先后顺序，先有服务器插件才有跨域

# sass
## 介绍
- 高效的css预编译语言
- 但是sass没有被任何浏览器支持，所以，sass在被投入项目使用之前一定要编译成css
- sass有ruby公司开发的，sass的文件是`.sass`后缀，这种文件最大的特点是不支持花括号和分号，对前端不友好
- 所以ruby公司开发了另一种写法，是`.scss`的后缀，这种文件全面支持css语法
- 市面上的搞高效的预编译语言还有less

## 如何将sass编译成css
- 编辑器的插件（vsCode）
- 在线编译：https://www.sassmeister.com/
- 借助前端自动化工具（gulp），配置sass转css的环境
	- gulp滋自身没编译sass的功能
	- 需要借助gulp的第三方插件：gulp-sass/gulp-sass-china
- 配置gulp中的sass编译功能
	- 引入：`const sass = require("gulp-sass")`
	- 定义编译功能
    ```js
    //配置sass转css
    function stc(){
        return src("./src/**/*.scss")
        .pipe(sass().on("error",sass.logError))//sass抛出错误事件，不会在自动保存时卡掉
        .pipe(dest("dist/project-sass"))
    }
    exports.stc = stc;
    ```
    - 为了编译方便、自动化，开启监听
    ```js
    //配置sass自动转css
    function autoStc(next){
        watch("./src/**/*.scss",stc)
        next()
    }
    exports.autoStc = autoStc;
    ```

## sass的语法
1. 注释
	- `"/* */"`：多行注释，会被sass编译位css
	- `"//"`：单行注释，不会被sass编译
2. 变量 
	- **单值变量**
		
     - `$`声明变量
        ```scss
        $color:green;
        .box{
        background-color: $color;
        }
	     ```
	- **多值变量**
		
   	- `$`声明变量
     - 变量内的值索引从1开始，使用nth方法遍历变量
        ```scss
        $color:red green yellow;
        .box1{
            color: nth($color,1);
        }
        .box2{
            color: nth($color,2);
        }
        .box3{
            color: nth($color,3);
	     }
	     ```
	- **list变量**
		
	- 相当于二维数组
   	
   	- `@each in `遍历数组是的方法
   - scss方法使用时必须加@
     
        ```scss
        $arr:(box,20,30,red)(cont,10,20,green)(msg,40,50,yellow)(top,60,20,pink)(bottom,10,30,#ccc);
        @each $s,$w,$h,$c in $arr {
            .#{$s}{
                width:$w;
                height:$h;
	             color:$c;
	         }
	     }
	     ```
   - **map变量**
   	
   	- 类似于对象
   	- `@each in`遍历map变量
     - @each 键，值 in map对象
        ```scss
        $obj:(h1:10,h2:20,h3:30);
        @each $k,$v in $obj {
            #{$k}{
                font-size:$v+px;
            }
        }
        ```
3. 嵌套
	- **选择器嵌套**
		
     - &:表示当前元素（相当于this）
        ```scss
        .list{
            background:#ccc;
            li{
                border:solid 1px black;
                &:hover{//&:表示当前元素（相当于this）
                    color:red
                }
            }
            .last{
                border:none
            }
        }
	     ```
	- **属性嵌套**
   	
     - 在**复合属性**内嵌套子属性，表示该属性的全写
        ```scss
        .box{
            border:{
                left:{//表示border-left
                    style:solid;
                    width:20px;
                    color:red;
                };
                right:{//表示border-right
                    style:solid;
                    width:20px;
                    color:yellow;
                };
                top:{//表示border-top
                    style:solid;
                    width:20px;
                    color:green;
                }
            }
        }
        ```
4. 混合代码块  mixin
	- 类似于函数，没有返回值
	- 是一个方法，需要加@
		- 定义代码块`@mixin css属性名($形参){css属性名:$形参}`
	- 使用`@include+css属性名(实参（css属性值）)` 调用代码块
    ```scss
    @mixin transform ($d) {
        -webkit-transform: $d;
        -moz-transform: $d;
        -ms-transform: $d;
        -o-transform: $d;
        transform: $d;
    }
    .box1{
        @include transform(rotate(90deg));
    }
    .box2{
        @include transform(translate(100px));
    }
    .box3{
        @include transform(scale(2));
    }
    ```
5. 函数
	- 定义函数：`@function 函数名(){@return }`
	- 调用函数：`函数名()`
    ```scss
    @function getNum(){
        @return 100;
    }
    .box1{
        width:getNum()+px;
    }
    .box2{
        height:getNum()+px;
    }
    ```
6. 运算
    ```
    1rem = html标签的font-size
    1em = 父元素的font-size
    1vw = 视口宽度/100
    1vh = 视口高度/100
    ```
	- 可以实现带单位的值的运算，最后*1rem/em就会转换成需要的单位
    ```scss
    //rem
    //默认16px
    //$fz:20px;
    html{
        font-size:$fz;
    }
    @function ptr($px){
        @return $px/$fz*1rem;
    }
    .box{
        width:ptr(200px);
        height:ptr(238px);
    }
    ```
7. 继承
	- 通过关键字`@extend`实现继承
    ```scss
    .box1{
        width:100px;height:100px;
        color: yellow;
    }
    .box2{
        @extend .box1;
        color:red
    }
    ```
8. 合并scss解析成一个css文件
	- @import "路径"
	- 使用关键字`@import`引入文件
	`@import "../style.scss";`
	
# 模块化开发
## 什么是模块化开发
- 是一种项目架构模式，这种架构模式让js代码重用性变得非常的高，让项目架构的一些复杂问题全部的以解决。例如多个script标签不会再出现，我们只需要用一个script标签引入就可以了
- 模块：独立的功能，复用性，耦合低
- 模块化：将整个项目功能化
- 一般来说，每个模块独立于一个js文件

## 为什么要用模块
- 为了减少系统耦合度、提高内聚，减少资源依赖
- 便于维护，功能复用性强
- 解决独立作用域，依赖管理，api暴露，安于加载于执行，安全合并等问题

## 如何实现模块化
- 实现方式多种多样
	- 独立的作用域，独立的功能
- 一个项目团队中，出现多种模块化的方式，不利于维护，代码合并，团队协作
- 需要统一模块化开发的方式：模块化规范

## 模块化规范
- CMD规范
	- 按需加载
	- 引入：sea.js
	- 断更
- AMD规范
	- 依赖前置
	- 引入：require.js
- nodeJs的模块化：commonJs
	- 引入：require()
	- 暴露：exports
- ES6的模块化
	- 引入：import from
	- 暴露：export
	- 只能在服务器环境运行

## AMD规范的使用
- 下载规范化文件
- 引入规范化文件
- 定义模块时***不执行***任何语句
- 使用：
	- 引入模块：require()/requirejs()
	- 参数1：数组，模块的路径
		- 参数2：函数
			- 函数的参数是模块暴露的接口
			- 参数1的数组有几个就有几个参数
	```js
  require(["./module2/mB","./module2/mA"],function(name,age){})
	```
	- 定义模块（暴露模块）：define()
	- 参数1：数组，模块依赖（可选）
		- 参数2：函数
			- 函数的return是暴露模块的途径
			- 返回一个对象
    ```js
    // 定义模块
    define(function(){
        // 模块的功能
        // 暴露模块入口
        return {
            // 上面封装的功能或变量
            age:666
        }
    });
    ```
- 注意：
	- 当main文件作为主模块，使用script标签的src引入时，main文件内部的小模块的路径起始点，以**引入了main文件的html文件**开始
	- 当使用AMD模块化规范时,script标签有一个自定义属性`data-main`用来引入main文件
		- main文件内部的小模块的路径起始点，以**当前main文件**开始
		- `"<script src="libs/require.js" data-main="js/main"></script>"`
	- baseUrl配置的路径起始点，**以引入的html文件为基准**
		- 在main文件中配置
		- require.config()
			- 参数：对像
		```js
		require.config({
			baseUrl:"module",//小模块所在的文件夹
			paths:{
				jq:"http://mat1.gtimg.com/libs/jquery2/2.2.0/jquery"
			}//简化文件名
		})
		require(["jq","mA","mB"],function(j,a,b){
            console.log("123123")
            console.log(a.a)
            a.show()
        })
		```
## ES6的模块化
- script标签必须加一个属性`type = "module"`
	
	- `"<script src="js/main.js" type="module"></script>"`
- 模块暴露时不可以直接暴露变量，可以采用花括号包裹的方式
	
	- export {a};
- 引入模块时变量也必须使用花括号包裹
	
	- `import {a} from "./module/m.js";`
- 模块内部修改不需要重新引入，可以拿到修改的值（动态绑定）
- `as`可以在暴露或引入时修改变量的名字
	
	```js
	var str = "as可以改名";
	export {str as s};
	```
	```js
	import {s as str} from "./module/m.js"
	```
- 可以同时暴露或接收多个参数
	```js
	var b = 20;
	var c = 30;
	function fn1(){	
		console.log(b+c);
	}
	export {b,c,fn1};
	```
	```js
	import {b,c,fn1} from "./module/m.js"
	```
- 当模块以default暴露时可以使用一个对象来接收
	- 此时这个对象身上有模块暴露的所有属性
	- 一个模块中只可以出现一个default
	- 使用default暴露的模块接收后可以修改值
	```js
	var b = 20;
	var c = 30;
	function fn1(){	
		console.log(b+c);
	}
	export {b,c,fn1};
	export default {b,c,fn1};
	```
	```js
	import obj from "./module/m.js"
	```
- 直接使用import+路劲可以引入立即执行的js文件（例：jqyrey）
	```js
	import "./module/jquery.2.2.4.js"
	console.log($)
	```
- ` * `：通配符，可以引入模块所有暴露的接口
	- 使用*时需要用as改名
    ```js
    var b1 = 22;
    var c1 = 33;
    var fn2 = function(){
        console.log(b1+c1);
    }
    export {b1,c1,fn2};
    ```
    ```js
    import * as obj1 from "./module/m.js"
    console.log(obj1)
    ```
- 注意：
	1. export和import关键字，只能存在于顶层作用域内，不能存在局部或块级作用域
	2. 在ES6的模块化中，所有语法自动处在严格模式下
	3. export是声明关键字，声明一个对外接口
	4. export声明的接口必须和模块内部的变量建立一一对应的关系
	5. export声明的接口与对应的值是动态绑定，即可以拿到模块内部实时修改的值
	6. export和import时，都可以使用as关键字，重命名接口
	7. 使用default关键字，设置默认接口，一个模块中只允许出现一次default
	8. import在使用接口时，必须将接口放在花括号内，除非export暴露接口时使用了default关键字
	9. import加载的接口是只读的，不允许被修改，如果接口是对象，可以修改属性
	10. import具有提升效果
	11. 由于import是静态执行，所以不能使用表达式和变量
	12. 当import后没有接收接口，会执行整个模块文件
	13. 可以使用通配符*加载整个模块的接口（需要配合as使用），返回一个模块对象
	14. ES6的模块化不是对象，而是通过export输出对应的代码，再通过import输入
	15. import加载模块的输入接口是静态加载，指定接口的情况下，只加载接口部分

# 版本管理

## 介绍
- 什么是版本管理
	- 版本，不仅仅限于代码文件，任何文件，任何资源，任何数据，都存在版本
- 版本管理的优势
	- 方便查看文件的发展趋势，历史的数据，历史数据的回退
- 怎么实现
	- 传统的文件管理：拷贝副本
		- 不安全，不方便管理
	- 交给计算机工具，管理源文件，数据流
		- 安全，节省空间，方便管理
- 管理方式的方式
	- **集中式**版本的管理（SVN）：所有的版本信息，都储存在当前计算机内，可以按需选择是否上传到服务器
	- **分布式**版本管理（git）：每个客户端的版本信息，都存储在当前计算机内，可以按需选择是否上传到服务器
- 工具的使用方式
	- SVN：下一标题（SVN的使用）
	- git：下一标题（git的使用）
- ***版本管理工具的概念***
	- 工作区：正在编写文件的空间
		👇add
	- 暂存区：队列，等待上传文件所在的区域
		👇commit
	- 版本库：记录当前版本，产生一个版本库和对应的版本描述

## SVN的使用
1. 下载，安装
2. 通过右键菜单中绑定的SVN选项，实现svn操作
3. 接入svn服务器：
	- 本地：安装SVN的服务器工具，创建SVN服务器，创建独立的项目
		- 安装软件->打开软件->创建项目->设置项目名称->得到服务器地址（注意是否对外地址）->将项目地址发给要连接服务器的使用者
	- 在线：找到第三方在线仓库网站，注册账号，创建项目
4. 打开要被版本管理工具管理的项目的根目录
5. 使用`checkout`命令接入服务器
	- 会利用右键菜单的选项，判断当前项目的管理状态
	- 没有`checkout`表示，已经建立连接了
6. 开始工作...
7. 将新文件，使用 `add` 命令，先添加到暂存区
	- 利用右键菜单的选项，判断当前文件的状态
	- 有`commit`表示，文件已经在暂存区了
8. 使用 `commit` 命令，将暂存区中的文件上传到版本库
	- 利用右键菜单的选项，判断当前文件的状态
	- 有`update`表示，文件已经在版本库了
9. 正常开发项目，重复6，7，8...
10. 版本回退
	- `updata to revision+版本号`
11. 如果出现上传失败，代码冲突
	- 两个用户修改了同一处代码
	- 线下沟通解决
		- 保留要保留的代码
		- 删除要删除的代码
	- 删除代码的那一方要先更新
	- 保留代码的那一方重新上传
	- 删除代码的那一方要再更新

## git的使用
1. 下载，安装 - 右键菜单会多出git的选项（按需重启电脑）
2. 打开要被版本管理工具管理像木的根目录
3. 右键菜单选择：gti Bash，检查当前路径是否指定文件夹
	- 路径不对的话，使用`cd`切换路径
4. 初始化git项目：`git init`
5. 配置全局用户信息
	- `git config --global user.name "${用户名}"`
	- `git config --global user.email "${邮箱地址}"`
6. 开始工作...
	- 查看状态：`git status`（查看暂存区状态）
7. 将新文件用 `git add` 命令线添加到暂存区
	- `git add .`
	- `git add *`
	- `git add -A`
	- `git add --all`
	- 以上都是将工作区所有文件上传到暂存区
8. 使用 `git commit` 命令，将暂存区的所有文件上传到版本库
	- `git commit -m "这里是版本日志"`
9. 正常开发项目，重复7，8，9...
10. 查看版本日志：`git log`
	- 如果版本日志数据过多，导致被折叠显示，可以使用上下箭头显示折叠信息，使用`q`退出折叠
11. 查看操作日志：`git reflog`
12. 版本回退：`git reset --hard 版本号`
13. 上传到git仓库
	- 建立连接：`git remote add origin 仓库地址`
	- 推送版本：`git push -u origin master(分支)`
14. 输入用户名密码
15. 只有第一次上传需要建立连接，以后只需要`git push`即可
16. 刷新在线仓库可拿到版本文件和信息
17. 从仓库下载到本地
	- 完整的克隆整个项目：`git clone 仓库地址`
	- 拉取线上版本与本地版本合并：`git pull[origin][master]`
		- 中括号代表可以省略
18. 分支（branch）
	- 什么式分支？副本、备份
	- 原则上来说，每个开发者，每个功能，都因该在一个新的分支上进行，而不要执黑在项目上进行操作
	- 默认情况下，整个项目是一个分支：主分支（master）
		- 创建一个子分支（拷贝主分支）`git branch 分支名字`
		- 干活...
		- 选择分支`git checkout 分支名字`
		- 合并到主分支`git merge 主分支`（一般需要先选择主分支，然后将其他分支合并到主分支）
		- 删除子分支 `git branch -d 分支名字`
19. 标签（标志，书签，tag）
	- 存在的意义，参考现实生活中的书签
	- 需要在连接仓库的情况下才可以创建标签
	- git tag                  查看标签
    - git tag name             创建标签
    - git push origin name     上传标签
    - git tag -d name          删除标签



## git常用命令
- `git config --global user.name "${用户名}"`- 设置全局用户名
- `git config --global user.email "${邮箱地址}"`- 设置全局邮箱
- `git init`- 初始化git，生成.git文件
- `git add .`- 添加工作区所有到暂存区
- `git commit -m "这里是版本日志"`- 将暂存区所有上传到版本库
- `git log`- 查看版本日志
- `git diff ` - 查看工作区与暂存区区别
- `git status`- 查看暂存取状态
- `git reflog`- 查看操作日志
- `git reset --hard 版本号`- 版本回退
- `git remote add origin 仓库地址`- 与仓库建立连接
- `git push -u origin master(分支)`- 上传到云端仓库
- `git clone 仓库地址`- 下载所有项目文件到本地
- `git pull[origin][master]`- 更新本地版本库与仓库一致
- `git branch`- 查看分支
- `git branch 分支名字`- 创建新分支
- `git checkout 分支名字`- 选择分支
-  `git merge name`合并分支（一般需要先选择主分支，然后将其他分支合并到主分支）


- 查看差别
    - git diff                  工作区和暂存区的差别
    - git diff --cached         暂存区和版本库的差别
    - gif diff HEAD             工作区和版本库的差别


- 添加到暂存区
    - git add .
    - git add *
    - git add --all
    - git add -A


- 查看日志
    - git log --oneline
    - git log -n


- 版本回退
    - git reset --hard HEAD^
    - git reset --hard HEAD~n
    - git reset --hrad 版本号


- 撤销
    - git checkout -- 文件名    撤销工作区修改

    - git reset HEAD 文件名
    - git checkout -- 文件名    撤销暂存区修改


- 远程仓库
    - git remote add 连接别名 连接地址
    - git remote -v
    - git remote remove 连接别名


- 标签操作（需要在连接仓库的前提下）
    - git tag                  查看标签
    - git tag name             创建标签
    - git push origin name     上传标签
    - git tag -d name          删除标签


- 分支操作
    - git branch               查看分支
    - git branch -r            查看远程分支
    - git branch -a            查看所有分支
    - git branch name          创建分支
    - git checkout name        选择分支
    - git branch -b name       创建并切换分支
    - git merge name           合并分支（一般需要先选择主分支，然后将其他分支合并到主分支）
    - git branch -d name       删除分支

- 忽略指定文件夹或文件
	- .gitignore文件内，写明要忽略的文件夹或文件



## ***SVN和git的区别*
- SVN的存储需要依赖一个服务器，而git所有的东西是放在线上的。节约成本，省时省力。
- git 是分布式的，svn 是集中式。
- git 按照源数据的方式存储内容，svn 是按照文件的形式存储
- git 和 svn 中的分支不同。
- git 没有全局版本号，svn 有。
- git 内容的完整性优于 svn。